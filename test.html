Old meg bash parancsokkal:

01. 
Hozz létre egy projekt könyvtárat a home könyvtárádban. Ebben a könyvtárban hozz létre egy dokumentumok alkönyvtárat és egy kepek alkönyvtárat.

02. 
Hozz létre egy fontos.txt nevű fájlt a projekt/dokumentumok könyvtárban és egy kep1.jpg és kep2.jpg fájlt a projekt/kepek könyvtárban.

03. 
Másold le a fontos.txt fájlt a backup könyvtárba.

04.
Másold le a kep1.jpg fájlt a projekt/kepek könyvtárból a projekt/dokumentumok könyvtárba és nevezd át dokumentum.jpg-re.

05.
Listázd ki a projekt könyvtár tartalmát.

06.
Listázd ki a projekt könyvtár tartalmát, beleértve a rejtett fájlokat is.

07.
Töröld a kep2.jpg fájlt a projekt/kepek könyvtárból.

08.
Töröld az egész projekt könyvtárat.

09.
Hozz létre egy osztalyok/matematika könyvtárat a home könyvtáradba.

10.
Hozz létre egy jegyzetek/2022 könyvtárat, majd a 2022 könyvtárban hozz létre egy jegyzet.txt nevű fájlt.

----------------------------------------------------------------

OS. gyak 2
---
echo, mv, cat, >, >>, ln, chmod, head, tail

Szöveg kiíratás:
echo: szöveg kiíratása a konzolba
echo szöveg
Ha több space-t írunk, akkor is csak egy spacet használ, mert a szavakat paraméterként dolgozza fel és feltételezi, hogy a space maga szóelválasztó
Megoldás: idézőjeleket kell használni
Automatikusan sort emelt, ha ezt nem akarjuk, akkor -n kapcsoló
-e escape szekveniák használata (pl. prog 1, printf: \t tabulátor, \n új sor)

Áthelyezés:
mv forrásfájl célfájl: fájlok áthelyezése
Ugyanazon mappába kell áthelyezni egy fájlt, akkor átnevezi a fájl
Ha két könyvtár eltér, akkor áthelyezés is történik
Ha célfájl létezik, akkor ezt a mv parancs felül fogja írni

Tobb fájl esetén mindegyiket a célmappába fogja átmozhatni (egyezés esetén felülírás)
mv -i: áthelyezés kérdéssel

Fájlok tartalának kiíratása:
cat fáj1, fájl2, fájl3: fájlok tartalmának kiíratása
cat *.txt: kiírja az összes txt kiterjesztésú fájl tartalmát
cat paraméter nélkül, visszadja azt amit beírunk a konzolba (Ctrl+D-vel jelezzük a bevitel végét
hosszú fájl esetén cat parancsa csak annyit mutat, amennyi kifér a képernyőre

less fájlnév: képernyőként megy a tartalomon (kilépés a q gombbal)
more fájlnév: hasonló, csak egy kicsit kevesebb tudással, mint a less (space: léptetés, q: kilépés)

Kimenet átirányítása (pl. egy fájlba)
---
A kisebb nagyobb jel segítségével egy fájlba tudjuk irányítani a parancssor kimenetét
ls -l
ls -l > list.txt
more lista.txt
Fájlnév egyezés esetén felülírja a fájlt

>> (dupla kisebb nagyobbb jel): hozzáfűzzük a fájl végéhez

cat allatok.txt >> lista.txt (a lista.txt végére fűzi az állatok.txt fájlt)
cat > newfile.txt: tartalom létrehozása, ennél jobb megoldás egy szerkesztő használata pl. nano, vim

nano file.dat

Bemenet átirányítása (pl. egy fájlba)
---
./pelda < bemenet.txt a példa fájlnak hozzáadjuk bemenetként a bemenet.txt fájl

c kód futtatása esetén telepíteni kell a gcc-t 
sudo apt-get update
sudo apt-get install gcc

Fájlok linkelése
---

Soft link
Egy olyan speciális fájl, amely egy másik fájl elérési útját tartalmazza
Egy link mutathat fájlra vagy könyvtárra is. Ez egyenértékű azzal, mint ha a másik fájlra hivatkoznánk kivéve (átnevezés, törlés stb.)
Például egy gyakran használt fájlt amely nem a home könyvtáramban van, arra érdemes lehet készíteni egy hivatkozást

ln -s (soft link) létező fájl [célkönyvtár vagy célfájl]

Pl.:
ln -s banan.txt bananlink
ls -l bananlink
lrwxrwxrwx 1 balazs balazs 9 Feb 22 13:31 bananlink -> banan.txt

Emlékeztető: az ls -l paranccsal látható a hivatkozás, hogy hova mutat.

Ha törlöm az eredeti fájt, akkor a link meghíváskor kiírja, hogy nincs ilyen fájl.

Hard link
Az eredeti tartalomhoz két fájlt hozunk létre.
ln létező fájl hivatkozással új fájl jön létre.

ls -l esetén regular fájlként lesz kilistázva, de a linkszámláláló nőtt

Ha egy állományt törlök, akkor a másik megmaradt, a link 2-ről 1-re változik
Könyvtárra hard linket nem lehet létrehozni, továbbá ha több fájlrendszer van, akkor a fájlrendszerek között csak soft linket lehet használni

Jogosultsások módosítása
---

Kinek:
u: user (tulajdonos)
g: group (csoport)
o: others (mások)
a: all (mindenki)

Mit:
r: read (olvasási jog)
w: write (írási jog)
x: execure (vágrehajtási/belépési jog)
+: megad, -: elvesz

-rw-r--r-- 1 balazs balazs   274 Apr  1  2021  zh01.sh

chmod modosítás fájlok neve
chmod o+w szoveg.txt (jogosultság hozzáadása)
chmod o-w szoveg.txt (jogosultság elvétele)

Oktális számok
x: 1-esk
w: 2-esek
r: 4-esek
-: 0-sok

chmod 644 szoveg.txt

senki semmilyen jogosultság: 000
mindenkinek minden jogosultság: 777

Kitekintő:
chown ujtulaj fájlnév/elérés: új tulajdonos létrehozása
chgrp ujcsoport fájlnév/elérés: új csoport létrehozása
kombinálva: chown jozsef:security server.log (sudo használatára van szükség)    

Fájl eleje és vége
---
head -n szám fájlnév: fájl első szám sorát íratja ki
Ha nincs annyi sor, mint amennyit kérünk, nincs hiba
tail -n szám fájlnév: fájl utolsó szám sorát íratja ki

Kitekintés:
tail -f tail miután kiírt x sort, nem tér vissza, hanem folyamatosan nézi, hogy kerülnek-e újabb sorok a fájlba, és azokat kiíratja, pl. log fájlok folyamatos bővülése

----------------------------------------------------------------

OS. gyak 3
---
pipe(|), wc, cut, sort, ps, fg, kill, find

Programok összefűzése a pipe paranccsal segítségével
Programokat amelyekak konzolra írnak és konzolról olvasnak összefűzzük (pipeolás)
ls -l | tail -n 5: részletes listát átadja a tailnek, amely kilistázza az utolsó 5 sort 
cat olvassel.txt | head -n 5: az olvassel.txt első 5 sorát adja vissza

Több fájl esetén kiíratja a nevét, amelyet -q kapcsoló el lehet tüntetni

cat fájl1.txt fájl2.txt | head -n 2: a fájl1.txt és fájl2.txt a cat által egyesített megjelenítésének első két sorát iratja ki

Pipe több parancsot is egybe lehet fűzni
Írassuk ki egy fájl 2. sorát

cat sorok.txt - jelenítse meg mindet
cat sorok.txt | head -n 2 - jelenítse meg az első kettőt
cat sorok.txt | head -n 2 | tail -n 1 - jelenítse meg az első kettőből az utolsót
 
Írassuk ki egy fájl utolsó előtti sorát
 
cat sorok.txt - jelenítse meg mindet
cat sorok.txt | tail -n 2 - jelenítse meg az utolsó kettőt
cat sorok.txt | tail -n 2 | head -n 1 | jelenítse meg az utolsó kettőből az elsőt

Sorok, szavak, karakterek száma:
wc parancs
wc -l: sorok száma
wc -w: szavak száma
wc -c: karakterek száma

Az előbbiek kombinálhatók is
wc -wl: a szavakat és a sorokat is számolja meg
wc minden kiír

Pipe esetén használható, pl. számolja meg hány bejegyzés van az adott könyvtárban

ls -1 | wc -l: a bejegyzések kiíratása egy oszlopba, majd sorok számának összeszámolása
wc -l *.txt: az összes bejegyzés sorok száma, össz. száma

Cut (mezők vágása)
---
Adatott sorokból melyik mezőt adja vissza
cut -c kezdő-vég karakterek
cut -c 2-5 fájl.txt, a sorokból kivágja a 2-5 közötti karaktereket
cut -c 3 fájl.txt, csak a 3. karakterek

Példa, 1-3 karakter kivágása:
cat sorok.txt | cut -c 1-3

Mező vágása, egy elhatároló alapján (-d kapcsoló), amely alapesetben egy tab
cat sorok.txt | cut -d -f 2 (második oszlop kivágása -f kapcsoló segítségével)
cat sorok.txt | cut -d ';' -f 1 (első oszlop kivágása, egy olyan struktúrában, amelyeket ";"-al vannak elválasztva)

sort (rendezés)
pl. cat nevek.txt | sort (abc sorrend)

sort -r (csökkenő sorrend)
pl. cat nevek.txt | sort -r 

sort -k:  melyik mező szerint rendezzen
pl. ls -l | sort -k 6 (dátum növekvő)

sort -n: numerikus sorrendezés
pl. ls -l | sort -k 5 (méret növekvő)

Példa:
Jelenítse meg a könyvtárában a legnagyobb fájl adatait:
ls -l | sort -k 5 | tail -n 1
Jelenítse meg a könyvtárában a legkisebb fájl adatait:
ls -l | sort -k 5 | head -n 2 | tail -n 1

sort -u: egyező sorok elrejtése
pl. cat telefonszamok.txt | sort -u

Folyamatok:
A /proc alatt egy virtuális fájlrendszer található, ahol a futó folyamatokól tudhatunk meg információkat
pl. cat /proc/cpuinfo (a gép CPU adatainak lekérdezése)

ps: saját folyamataimat mutatja
Összes felhasználó összes folyamata bővített formátumban:
ps aux (a - összes, u - felhasználók, x - bővített formátum)

Folyamat leállítása: kill

pl.
nano lorem.txt
új terminálablak indítása
ps aux (kilistázom a folyamatokat)
Ezt követően kiválasztom a leállítandó folyamat PID-ját, és ezt adom meg a kill parancs paraméterének
kill 1322

ps f (gyerek folyamatok kilistáza)

killall folyamatnév: összes meghatározott nevű folyamat leállítása

Futó folyamatok listázáta: jobs
Futó folyamat háttérbe helyezése:
nano lorem.txt & (háttérben fusson), vagy futás közben ctrl + z 
ezt követően kiírja a rendszer, hogy
[1] - 1 jobs
234567 - Process id

Első (1) job előtérbe helyezése:
fg 1 (első jobot)

Felfüggesztett folyamat leállítás:
kill pid (process id)
kill -9 %1 (-9/SIGKILL %job id)

Keresés: find parancs
A find segítségével egy adott könyvtárban egy adott állományt/állományokat keresünk
Fontos, hogy alapesetben rekurzív, lemegy a legalsó gyerekig
Lehet, név, típus, vagy méret és egyéb tulajdonságok alapján

find könyvtár kapcsolók tulajdonságok/jellegek

-name: névre keressen
-iname: ne legyen kis/nagybetű érzékeny
-regexp: reguláris kifejezés
-type f, -type d: fájl/könyvtár
-size: méret
-exec: a megtalált fájlokon egy parancsot hajtson végre
-maxdepth: könyvtár mélység
-group: csoport definiálása

Példák (a "." az aktuális mappa helye, átírható tetszőleges struktúrára):

find . -name hudemely.txt
find . -name "*.txt"
find . mappa -type f -name "*.txt" (fontos: a reguláris kifejezéseket idézőjel közé kell tenni)

find . -type f -name "*.txt" -exec ls -l "{}" \; {ide hellyetesítődik be amit a find talál}

Összes könytár információ kilistázásaa
find . -type d -exec ls -ld "{}" \; (ls -ld: könyvtár információk kilistázása hosszú formátumban)

Összes txt fájl első két sorának kiíratása
find . -type f -name "*.txt" -exec head -n 2 "{}" \;   

Hány sorból állnak a .txt kiterjesztésű fájlok
find . -type f -name "*.txt" -exec wc -l "{}" \;

Biztonsági mentés egy mappába
find . -maxdepth 1 -type f -name "*.txt" -exec cp "{}" ./backup/"{}".bak \;

A txt fájloknak összesen hány soruk van
find . -type f -name "*.txt" -exec cat "{}" \; | wc -l

A txt fájloknak összes sorát rendezzük és lapozhatóvá tegyük
find . -type f -name "*.txt" -exec cat "{}" \; | sort | more




01.
Hozz létre egy projekt könyvtárat a home könyvtárádban. Ebben a könyvtárban hozz létre egy dokumentumok alkönyvtárat és egy kepek alkönyvtárat.
# 01
mkdir -p ~/projekt/{dokumentumok,kepek}

02.
Hozz létre egy fontos.txt nevű fájlt a projekt/dokumentumok könyvtárban és egy kep1.jpg és kep2.jpg fájlt a projekt/kepek könyvtárban.
# 02
touch ~/projekt/dokumentumok/fontos.txt ~/projekt/kepek/kep1.jpg ~/projekt/kepek/kep2.jpg

03.
Másold le a fontos.txt fájlt a backup könyvtárba.
# 03
cp ~/projekt/dokumentumok/fontos.txt ~/backup/fontos.txt

04.
Másold le a kep1.jpg fájlt a projekt/kepek könyvtárból a projekt/dokumentumok könyvtárba és nevezd át dokumentum.jpg-re.
# 04
cp ~/projekt/kepek/kep1.jpg ~/projekt/dokumentumok/dokumentum.jpg

05.
Listázd ki a projekt könyvtár tartalmát.
# 05
ls ~/projekt

06.
Listázd ki a projekt könyvtár tartalmát, beleértve a rejtett fájlokat is.
# 06
ls -a ~/projekt

07.
Töröld a kep2.jpg fájlt a projekt/kepek könyvtárból.
# 07
rm ~/projekt/kepek/kep2.jpg

08.
Töröld az egész projekt könyvtárat.
# 08
rm -r ~/projekt

09.
Hozz létre egy osztalyok/matematika könyvtárat a home könyvtáradba.
# 09
mkdir -p ~/osztalyok/matematika

10.
Hozz létre egy jegyzetek/2022 könyvtárat, majd a 2022 könyvtárban hozz létre egy jegyzet.txt nevű fájlt.
# 10
mkdir -p ~/jegyzetek/2022 && touch ~/jegyzetek/2022/jegyzet.txt

01.
Hozz létre egy új könyvtárat "gyakorlas" néven a home könyvtáradban.
# 01
mkdir ~/gyakorlas

02.
Hozz létre egy "szoveg.txt" nevű szöveges fájlt a "gyakorlas" könyvtárban, és írj bele egy tetszőleges szöveget az echo parancs segítségével.
# 02
echo "Egy tetszőleges szöveg." > ~/gyakorlas/szoveg.txt

03. Bővítsd ki a szoveg.txt fájlt a Nano szerkesztő segítségével a következő sorokkal:
# 03
nano ~/gyakorlas/szoveg.txt
# A nano-ban írd be a kért szövegeket, majd mentés: Ctrl+O, kilépés: Ctrl+X

04.
Hozz létre egy másolatot a "szoveg.txt" fájlról a "gyakorlas" könyvtárban, és nevezd át "masolat.txt"-re.
# 04
cp ~/gyakorlas/szoveg.txt ~/gyakorlas/masolat.txt

05.
Fűzd hozzá a "szoveg.txt" fájl tartalmát a "masolat.txt" fájlhoz.
# 05
cat ~/gyakorlas/szoveg.txt >> ~/gyakorlas/masolat.txt

06.
Helyezd át a szoveg.txt-t a projekt könyvtárba és nevezd át dokumentumok.txt-re.
# 06
mv ~/gyakorlas/szoveg.txt ~/projekt/dokumentumok.txt

07.
Módosítsd a "masolat.txt" fájl jogosultságait úgy, hogy csak a tulajdonos olvashassa és írhasa.
# 07
chmod 600 ~/gyakorlas/masolat.txt

08.
Listázd ki a "gyakorlas" könyvtár tartalmát, beleértve a rejtett fájlokat is.
# 08
ls -a ~/gyakorlas

09.
Írd ki a "masolat.txt" fájl első 3 sorát a konzolra.
# 09
head -n 3 ~/gyakorlas/masolat.txt

10.
Írd ki a "masolat.txt" fájl utolsó 4 sorát a konzolra.
# 10
tail -n 4 ~/gyakorlas/masolat.txt

11.
Hozz létre egy eredeti.txt fájlt a home könyvtáradban a következő tartalommal: "Jul  6 06:33:44 user1 ubuntu: dear cj"
# 11
echo "Jul  6 06:33:44 user1 ubuntu: dear cj" > ~/eredeti.txt

12.
Készíts az eredeti.txt fájlról egy soft linket soft_link.txt néven.
# 12
ln -s ~/eredeti.txt ~/soft_link.txt

13.
Ellenőrizd a linket. Honnan látszik, hogy elkészült a soft link?
# 13
ls -l ~/soft_link.txt

14.
Készíts az eredeti.txt fájlról egy hard linket hard_link.txt néven.
# 14
ln ~/eredeti.txt ~/hard_link.txt

15.
Ellenőrizd a linket. Honnan látszik, hogy elkészült a hard link?
# 15
ls -l ~/hard_link.txt

01.
Hozz létre egy "dokumentumok" nevű könyvtárat, majd benne egy "fontos.txt" fájlt, amelynek az első három sorába írd bele a következő adatokat az echo parancs segítségével:
# 01
mkdir ~/dokumentumok && echo -e "Kovács;Lajos;Baja;6500\\nNagy;László;Székesfehérvár;8000\ \nTamási;Péter;Veszprém;8200" > ~/dokumentumok/fontos.txt

02.
Készíts egy "projekt" nevű könyvtárat, majd benne egy "adatok.txt" és "kimenet.txt" fájlt! A "kimenet.txt" üres legyen az "adatok.txt" pedig a következőket tartalmazza:
# 02
mkdir ~/projekt && touch ~/projekt/adatok.txt ~/projekt/kimenet.txt && echo -e "Kovacs Tamas    Szeged  6000    06-30-3874656\\nSzanto Katalatin        Szekesfehervar  8000    06-20-2398763\\nNagy Lilla      Veszprem        8200    06-70-8574923\\nToth Tihamer    Budapest        1118    06-20-4987327\\nVince Iren      Balatonalmadi   8220    06-70-3977428\\nNagy Zsofi      Szeged  6000    06-70-8574923\\nZold Peter      Ajka    8400    06-20-2345976\\nPal Peter       Veszprem        8200    06-88-1234567" > ~/projekt/adatok.txt

03.
Listázd ki a "dokumentumok" könyvtár tartalmát, majd jelenítsd meg az utolsó három sort!
# 03
ls ~/dokumentumok && tail -n 3 ~/dokumentumok/fontos.txt

04.
Írasd ki egyszerre a "dokumentumok/fontos.txt" és "projekt/adatok.txt" fájlok tartalmának első négy sorát!
# 04
head -n 4 ~/dokumentumok/fontos.txt ~/projekt/adatok.txt

05.
Vágd ki a "projekt/adatok.txt" fájl tartalmának második és harmadik karakterét!
# 05
cut -c 2-3 ~/projekt/adatok.txt

06.
Rendezd sorrendbe az "dokumentumok/fontos.txt" sorait az első mező alapján növekvő sorrendben!
# 06
sort -t ';' -k1,1 ~/dokumentumok/fontos.txt

07.
Listázd ki az összes .txt fájlt a "projekt" könyvtárban, majd számold meg őket!
# 07
ls ~/projekt/*.txt | wc -l

08.
Vágd ki az "dokumentumok/fontos.txt" fájlban található sorok második mezőjét, amelyeket a ";" karakter választ el!
# 08
cut -d ';' -f2 ~/dokumentumok/fontos.txt


09.
Hozz létre három fájlt a "projekt" könyvtárban: "file1.txt", "file2.txt", "file3.txt". Minden fájl a következőt tartalmazza:
# 09
for i in {1..3}; do echo -e "1. sor: Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla ac justo vel nisi vestibulum aliquet.\\n2. sor: Suspendisse potenti. Fusce eget tincidunt risus, ac vehicula nulla. Quisque auctor justo nec ante ullamcorper, at sodales justo tempor.\\n3. sor: Integer ac justo vel orci consequat vulputate. In hac habitasse platea dictumst. Proin quis urna vel turpis dictum scelerisque.\\n4. sor: Etiam at vestibulum velit. Sed vel justo vel ipsum vehicula bibendum. Nulla facilisi.\\n5. sor: Vivamus fringilla mi vitae augue auctor, in scelerisque libero tristique. Nunc euismod, libero nec varius luctus, erat velit vulputate odio." > ~/projekt/file$i.txt; done

10.
Hozz létre egy "backup" nevű könyvtárat, majd másold át az "projekt" könyvtár összes .txt fájlját!
# 10
mkdir ~/backup && cp ~/projekt/*.txt ~/backup/

11.
Keress meg minden .txt fájlt kizárólag a "dokumentumok" könyvtárban.
# 11
find ~/dokumentumok -maxdepth 1 -type f -name "*.txt"

12.
Keress meg minden .txt fájlt rekurzívan a "projekt" könyvtárban, és írd ki a nevüket sorban!
# 12
find ~/projekt -type f -name "*.txt" -exec echo {} \;

13.
Keress meg minden .txt fájlt a "dokumentumok" könyvtárban, majd írd ki az első három sorát mindegyiknek!
# 13
find ~/dokumentumok -type f -name "*.txt" -exec head -n 3 {} \;

14.
Keress meg minden .txt fájlt a "backup" könyvtárban, majd másold át az összeset a "projekt" könyvtárba .old kiterjesztéssel!
# 14
find ~/backup -type f -name "*.txt" -exec cp {} ~/projekt/{}.old \;

15.
Keress meg minden .jpg fájlt a "~" könyvtárban, ne rekurzívan, amelyek mérete kisebb mint 50 KB!
# 15
find ~ -maxdepth 1 -type f -name "*.jpg" -size -50k


01.
Hozz létre egy "vizsga" nevű könyvtárat a home könyvtáradban.
# 01
mkdir ~/vizsga

02.
A "vizsga" könyvtárban hozz létre egy "lecke.txt" nevű fájlt, és írj bele egy tetszőleges szöveget.
# 02
echo "Ez egy tetszőleges szöveg a lecke.txt fájlba." > ~/vizsga/lecke.txt

03.
Listázd ki részletesen a "vizsga" könyvtár tartalmát.
# 03
ls -l ~/vizsga

04.
Másold át a "lecke.txt" fájlt a "vizsga" könyvtárból egy új "ismetles" nevű könyvtárba.
# 04
mkdir ~/vizsga/ismetles && cp ~/vizsga/lecke.txt ~/vizsga/ismetles/lecke.txt

05.
Nevezd át a "lecke.txt" fájlt "lecke_uj.txt"-re az "ismetles" könyvtárban.
# 05
mv ~/vizsga/ismetles/lecke.txt ~/vizsga/ismetles/lecke_uj.txt

06.
Töröld a "lecke_uj.txt" fájlt az "ismetles" könyvtárból.
# 06
rm ~/vizsga/ismetles/lecke_uj.txt

07.
Készíts egy "eredmenyek" nevű szövegfájlt a "vizsga" könyvtárban, ami tartalmazza a következő sorokat:
# 07
echo -e "Név: Kovács Béla\\nPontszám: 85" > ~/vizsga/eredmenyek.txt

08.
Hozz létre egy soft linket, "eredmeny_link" néven, ami az "eredmenyek.txt" fájlra mutat a "vizsga" könyvtárban.
# 08
ln -s ~/vizsga/eredmenyek.txt ~/vizsga/eredmeny_link

09.
Írd ki a "vizsga" könyvtárban lévő minden .txt fájl tartalmát.
# 09
cat ~/vizsga/*.txt

10.
Keresd meg és listázd ki az összes .txt kiterjesztésű fájlt a home könyvtáradban.
# 10
find ~/ -type f -name "*.txt"

11.
Rendezd sorrendbe az "eredmenyek.txt" fájlban lévő sorokat fordított abc sorrendbe és írd ki a képernyőre.
# 11
sort -r ~/vizsga/eredmenyek.txt

12.
Hozz létre egy "backup" könyvtárat a home könyvtáradban és másold át bele a "vizsga" könyvtár összes tartalmát.
# 12
mkdir ~/backup && cp -r ~/vizsga/* ~/backup/

13.
Készíts egy új fájlt "osszegzes.txt" néven a "vizsga" könyvtárban, ami tartalmazza az "eredmenyek.txt" és "lecke.txt" fájlok sorainak számát.
# 13
wc -l ~/vizsga/eredmenyek.txt ~/vizsga/lecke.txt > ~/vizsga/osszegzes.txt

14.
Keress meg minden .jpg kiterjesztésű fájlt a home könyvtárban, amelyek mérete nagyobb mint 100KB, és listázd ki őket.
# 14
find ~/ -type f -name "*.jpg" -size +100k

15.

Írd ki az "eredmenyek.txt" fájl első két sorát, majd fűzd hozzá a "lecke.txt" fájl utolsó sorát.

# 15

(head -n 2 ~/vizsga/eredmenyek.txt && tail -n 1 ~/vizsga/lecke.txt) > ~/vizsga/osszegzett.txt




Operációs rendszerek
1. Bevezetés
Felhasznált irodalom:
• Kóczy-Kondorosi (szerk.): Operációs rendszerek mérnöki megközelítésben
• Tanenbaum: Modern Operating Systems 2nd. Ed.
• Silberschatz, Galvin, Gagne: Operating System Concepts v3.0
2
Irodalom
• Kóczi-Kondorosi (szerk): Operációs rendszerek mérnöki
megközelítésben. Panem Könyvkiadó, 2000. ISBN:9635452500
• Tanenbaum, Woodhul: Operációs rendszerek. Műszaki
Könyvkiadó, 1999.
• Tanenbaum, Woodhull: Operációs rendszerek - tervezés és
implementáció. Panem Kft., 2007. ISBN: 9789635454761
• Silberschatz, Galvin, Gagne: Operating System Concepts.
Wiley, 2013. ISBN:9781118063330
• Tanenbaum, Bos: Modern Operating Systems. Pearson, 2015.
ISBN: 9780133591620
3
Miért kell operációs rendszereket tanulni?
• Fogok én valaha operációs rendszert készíteni?
– nem (valószínű)
• Szeretnék én valaha
hatékony programot készíteni?
– (remélhetőleg) igen
Ebben segíthet ez a tárgy!
4
Miért kell operációs rendszereket tanulni?
• Ahol számítógép – ott operációs rendszer
• Hogyan működik a számítógép
– Számítógép és operációs rendszer együtt
• Nagy rendszerek
– Alrendszerek, modulok, rétegek
• Komplexitás kezelés absztrakcióval
– CPU, memória, fájlok, szemaforok, erőforrások, interfészek
• Rendszertervezés
– Teljesítmény vs. egyszerűség
– HW vs. SW
5
Miért kell operációs rendszereket tanulni?
• Több program
– Konkurens feldolgozás
– Együttműködés
– Versenyhelyzet
• Erőforrás kezelés
• Memória kezelés
• Háttértár kezelés
• Fájlrendszer használat
• Teljesítmény analízis
6
1. Az operációs rendszerekről általában
• Az operációs rendszerek célja
• Az operációs rendszerek fogalma
• Az operációs rendszerek feladatai
7
1.1 Az operációs rendszerek célja
• felhasználók kényelme
– egyszerű, kényelmes, biztonságos
használat (elsősorban kis gépeknél
elsődleges, fontossága növekszik)
• hatékony gépkihasználás
– adott idő alatt minél több program
végrehajtása (nagy gépeknél elsődleges,
fontossága csökken)
8
1.2 Az operációs rendszer fogalma
DEF 1.
A számítógépen állandóan futó program
• Az a program, amely közvetlenül vezérli a gép működését
(operációs rendszer magja,
kernel).
•
Minden egyéb alkalmazói program.
DEF 2.
Az összes program, ami a szállítótól "operációs rendszer”-
ként érkezik.
• A gyakorlati feladatokat ellátó programok.
• Minden ami a gép "általános" felhasználásához szükséges.
• Pl. grafikus felület, editor, számológép,...
9
1.3 Az operációs rendszerek feladatai
1. Végrehajtási környezet
2. Erőforrás kiosztás
3. Vezérlő program
10
Operációs rendszer feladatai 1
• Végrehajtási környezet
– Olyan környezet, ahol a felhasználók és
programjaik hasznos munkát végezhetnek.
– A számítógép hardver szolgáltatásainak
bővítése
– Elrejti a „piszkos” részleteket, könnyű
felhasználhatóságot biztosít
11
Operációs rendszer feladatai 2
• Erőforrás kiosztás
– Kezeli a rendszer erőforrásait
• CPU,
• központi tár,
• merevlemez, stb.
– Tulajdonságai:
• hatékony
• biztonságos
• igazságos felhasználás.
12
Operációs rendszer feladatai 3
• Vezérlő program
– vezérli a felhasználói programok
működését,
– a felhasználói programok helyett vezérli a
perifériák működését.
13
Számítógépes rendszerek
HW
Operációs rendszer
Rendszer- és alkalmazói programok
Felhasználó 1. Felhasználó 2. Felhasználó N.
Gépi kód
Mikrokód
Fizikai eszközök
Operációs rendszer
Szövegszerkesztők
Fordítók
Command Interpreter
Web böngésző
Banki rendszerek
stb...
14
Statisztika
2023:
• Asztali operációs rendszerek (statista.com)
• Mobil operációs rendszerek (statcounter.com)
3,12%20,42%84,1%
69,94% 29,32% 0,74%
3,24%
15
Statisztika
16
Statisztika
17
2. Az operációs rendszerek története
• Első generáció (1945-1955)
• Második generáció (1955-1965)
• Harmadik generáció (1965-1980)
• Negyedik generáció (1980- )
18
2.1 Első generáció
Nincs operációs rendszer (1945-1955)
– Hardver: nagy, drága, megbízhatatlan,
plugboard vezérelt CPU, egyszerű
perifériák
– Használat: programozó = operátor, kézi
vezérlés, gépidő foglalás
– Mindent mindenki maga csinál, sok hiba,
hibakeresés, ebből adódóan rossz
kihasználtság.
19
Plugboard
20
Programok
Egyszerű matematikai és számtani
problémák
– Szinusz, koszinusz, logaritmus táblázatok
– Trajektóriák
– (Adószámítások)
21
Lyukkártya
Plugboard leváltása
22
2.2 Második generáció
Nincs operációs rendszer (1955-1965)
– Hardver: kisebb, olcsóbb, megbízhatóbb,
egyszerű perifériák, mágnesszalag
– Használat: programozó és operátor
szétválik
– Képzett operátor: gyorsabb gépkezelés,
de hibakeresés még nincs
– Programozó: papír, lyukkártya, job, papír
23
Job
Program vagy programok halmaza
– Program
– Azonosítók
– Végrehajtási utasítások
– Fordító
24
Példa
25
Job Control Language
$JOB - munka kezdete
$END - munka vége
$FORTRAN - FORTRAN fordító
$ASM - az assembler hívása
$LOAD - program betöltése
$RUN - program futtatása
26
Kötegelt (batch) feldolgozás
• Probléma
– Sok idő megy el a job összeállításával
– Közben áll a drága CPU
• Ötlet
– Off-line I/O műveletek
– Az operátor kötegekbe (batch)
csoportosítja a munkákat (jobs)
– Egyszerre több job-ot visz be a gépbe
– Gép sorosan feldolgozza a job-okat
27
Mágnesszalag megjelenése
• Bemenet szalagról (lényegesen gyorsabb
mint a kártya). Egy másik gép végzi a
másolást kártyáról a szalagra. Kimenet
hasonló. (+2 gép)
• Az I/O műveletek felgyorsulnak, a
processzor kihasználtsága nő.
• A három számítógép párhuzamosan
működik.
• Periféria-független programok, szabványos
felületek.
28
Off-line I/O műveletek
a) Kártya a 1401-be
b) Kártya másolása szalagra
c) Szalag a 7094-hez
d) 7094 elvégzi a számítást
e) Szalag a 1401-be
f) 1401 kinyomtatja az eredményt
29
Programok
Tudományos és mérnöki számítások
– Parciális differenciál egyenletek
– (Könyvelés)
30
Merevlemez megjelenése
Egyszerű monitor: ős operációs rendszer
– A gép vezérlését egy állandóan a memóriában
lévő program (a monitor) végzi, az operátor a
perifériákat kezeli.
– A munkához rendelt vezérlő információkat a
monitor értelmezi, végrehajtja, akár sorrendet is
módosíthat a véletlen elérésnek köszönhetően
– Egy tevékenység befejezése után újra a monitor
kapja meg a vezérlést, amely beolvassa a
következő munkát.
31
Kötegelt rendszer memória-kiosztása
Memória partíciók
Monitor
Felhasználói memória
32
2.3. Harmadik generáció
• Operációs rendszer megjelenik (1965-1980)
– operátorok szerepe csökken
• Hardver
– még kisebb, még olcsóbb
• A CPU sebessége jelentősen megnőtt
– érdemes kihasználni az időt, amíg egy munka a
lemezről olvasás eredményére vár
– erre az időre másik program működhet
– az OS egyszerre több munkát futtat ->
multiprogramozás
33
Programok
• Tudományos és mérnöki számítások
• Kereskedelmi alkalmazások
34
Multiprogramozott rendszer memória-kiosztása
Memória partíciók
Operációs rendszer
Job #1
Job #2
Job #3
35
A multiprogramozás lépései
• A rendszer nyilvántartja és tárolja a
futtatandó munkákat.
• A kiválasztott munka addig fut, amíg
várakozni nem kényszerül.
• Az OS feljegyzi a várakozás okát, majd
kiválaszt egy másik futni képes munkát és
azt elindítja.
• Ha a félbehagyott munka várakozási
feltételei teljesülnek, akkor azt alkalmasint
elindítja.
36
A multiprogramozás problémái
• Az átkapcsoláshoz több program van a
tárban:
tárgazdálkodás.
• Egy időben több futásra kész program:
CPU
ütemezés.
• A gépi erőforrások felhasználásának
koordinációja:
allokáció, holtpont kezelés.
• A programok ne zavarják egymást és az OS-
t:
védelmi mechanizmusok.
37
Perifériás műveletek gyorsítása
• A munkák között automatikus az átkapcsolás
GYORS
• A perifériák sebessége a CPU-hoz képest
LASSÚ
• Megoldások:
– Off-line I/O műveletek (lásd korábban)
– Pufferelés
– Spooling (Simultaneous Peripheral Operations
On-line)
38
Pufferelés
• CPU és a periféria vezérlő egyidejűleg
működnek. A beolvasás pufferbe (központi
memória) megy. Egy adott job adatfeldol-
gozási és I/O művelete átlapoltan történik.
• Pufferek mérete növekszik (blokkos átvitel).
• Csak akkor jelent hosszú távú sebesség
növekedést, ha az I/O és a CPU műveletek
kb. azonos időt vesznek igénybe (ami
általában nem igaz).
39
Spooling
Spooling (Simultaneous Peripheral Operations
On-line):
• A lassú perifériák adatait a feldolgozásig a
kisméretű puffer helyett mágneslemezen
tárolják.
• A partícióba a mágneslemezről kerül be.
• Különböző munkák perifériás és feldolgozási
műveletei átlapolódhatnak.
• A lemez véletlen hozzáférése lehetővé teszi
a munkák sorrendjének megválasztását.
40
Timesharing
• A harmadik generációs rendszerek is
alapvetően még batch rendszerek voltak
• Egy job átfutása sokáig tartott
• Gyorsabb reakcióidőt szerettek volna a
programozók
• Azt az érzetet, hogy csak ők használják a gépet
• Terminál „minden” programozónak
• MULTICS (MULTiplexed Information and
Computing Service) OS
41
2.4 Negyedik generáció
• 1980- (
főleg személyi számítógépek)
• Hardver: kicsi, olcsó, nem csak
cégeknek megfizethető
• Korszerű kötegelt rendszerek
• Időosztásos rendszerek
• Valós idejű rendszerek
• Elosztott operációs rendszerek
• Beágyazott operációs rendszerek
42
Korszerű kötegelt rendszerek
Csak nagy számítógépeken !!
• A gyors véletlen-hozzáférésű mágneslemezek miatt
megszűnt a kötegelt rendszerek szükségessége.
• A jelenlegi rendszerekben a programok futásába
nem lehet interaktívan beavatkozni, csak előre
összeállított munkák futnak.
• Hátrányok:
– Átfutási idő hosszú. (Egy munkának a rendszerbe adása és
az eredmény közti idő.)
– A programok csak statikusan, az eredmények alapján
fejleszthetők, használhatók. Az átfutási idő megnehezíti a
programokkal történő kísérletezést.
43
Időosztásos rendszerek
• A időosztásos rendszer (timesharing, multitask
systems)
közvetlen interaktív kommunikációt biztosít
a felhasználó és a programja, ill. az OS között.
• Adatok tárolása közvetlenül (on-line) az
állományrendszerben.
• A felhasználó interakciója nagyon lassú, közben az
OS más tevékenységet tud végrehajtani.
• Gyors reakció a parancsokra, válaszidő (response
time) kicsi. Sűrűn kell a programok között
kapcsolgatni.
• Felhasználók függetlenül használják a gépet, mintha
mindenki egy saját gépen dolgozna.
44
Elosztott operációs rendszerek
• A számításokat több központi egység között osztják
meg egyenletesen (multiprocessing)
• A felhasználó ezt nem veszi észre (transzparens)
• Szervezési elvek:
– Azonosak-e a processzorok
• homogén ↔ inhomogén
– Van-e kitüntetett processzor:
• szimmetrikus ↔ aszimmetrikus
– Csatolás
• szorosan csatolt (tár egy részét közösen használják)
• nem szorosan csatolt (a CPU-kat kommunikációs csatorna köti
össze) [elosztott rendszerek általában ilyenek]
45
Elosztott operációs rendszerek
kommunikációja
• Hálózati infrastruktúra kell (LAN vagy WAN)
• Architektúra: kliens-szerver, vagy peer-to-peer
Példa: egy kliens-szerver architektúra:
Üzenet egy klienstől egy szerver számára
46
Elosztott operációs rendszerek előnyei
• Erőforrások megosztása
– A felhasználó a másik gép erőforrásait (spec. hardver,
perifériák, állományok adatbázisok) használhatja
• Terhelés megosztás
– párhuzamosan végrehajtható részeket szét lehet osztani
– megnövelt teljesítmény
• Megbízhatóság
– Egy elem kiesése esetén a többi elem átveheti a szerepét.
• Homogén esetén könnyebb, inhomogén esetében nehezebb
•
„graceful degradation”
• Kommunikáció
– Programok, felhasználók közötti információ csere.
47
Valósidejű rendszerek
• Kemény valós idejű rendszerek (hard real-time)
– Szigorúan definiált és betartott válaszidők
– Kritikus rendszerek (pl. atomreaktor, járművek)
– Adattárolás: RAM, ROM, másodlagos tárolást (diszk) nem
támogatják
– Általános célú operációs rendszerek nem támogatják
• Puha valós idejű rendszerek (soft real-time)
– A válaszidők betartására törekednek, csúszás megengedett
– Nem kritikus folyamatirányítási feladatok
– Multimédia rendszerek, virtuális valóság
48
Beágyazott operációs rendszerek
• Háztartási berendezések,
mobiltelefonok, járművek, játékok
• Nem általános célú, nem független az
alkalmazástól (összefordul)
• Korlátos erőforrások, korlátos
szolgáltatások. OS-nek csak a
szükséges része fordul be.
49
3. Az operációs rendszerek szerkezete
• OS:
– nagyméretű
– komplex program,
– belső szerkezetük részekből áll.
• A felosztásnál
rétegeket különböztetünk meg:
– egymásra épülnek
– az alattuk elhelyezkedő réteggel jól definiált felülettel érintkeznek
– egyre bővülő funkcionalitás.
• Legalább 3 réteg:
– hardver
– operációs rendszer
– felhasználói programok
HW
Operációs rendszer
Rendszer- és alkalmazói programok
Felhasználó 1. Felhasználó 2. Felhasználó N.
50
Rétegszerkezet
• Tovább bontott rétegek. pl:
• 1. felhasználói programok
• 2. periféria meghajtók
• 3. virtuális tár kezelése
• 4. I/O csatornák
• 5. CPU ütemezése
• 6. hardver
Tendencia a
kevés réteg.
51
Rétegszerkezet
• Tiszta rétegszerkezetű rendszerek: csak az
alatta és felette levő réteggel kommunikál, a
rétegek feladatainak egymásra épülését
megnehezíti.
• Modulok, a rétegen belüli strukturálás: egy-
egy jól meghatározott feladatcsoportra egy
modul.
• A modulok egymás között kommunikálnak,
egységes mechanizmus.
52
4. Az operációs rendszerek feladatai
• Rendszerhívások
• Fontosabb rendszermodulok
• Szolgáltatások
• Rendszerprogramok
53
4.1 Rendszerhívások
• Program - OS közötti felület szigorúan
rögzített.
• A programok csak ezt látják.
• A rendszer szolgáltatásainak igénybevétele:
rendszerhívások.
• Rendszerhívás speciális gépi utasítás
segítségével történik (trap). A vezérlést az
OS programjának adja.
– assembly-ből közvetlenül kiadhatók (pl. DOS
int010 megszakítás)
– magasszintű nyelveknél könyvtári eljárások
54
A rendszerhívás lépései
• Paraméter átadás (1,2,3)
– Az OS által megadott helyre kell elhelyezni.
• Hívás, hardver működési mód váltás (4,5,6)
– felhasználói mód (korlátozott, bizonyos utasítások nem) 
rendszer mód (módváltás).
– A rendszerhívó gépi utasítás végzi el.
• Paraméterek kiolvasása, elágazás a hívott
szolgáltatáshoz (a rendszerhívás célját megvalósító
kód végrehajtása) (7)
• Visszaadott paraméterek másolása (8)
• Visszatérés a hívóhoz (módváltás) (9)
• Hívó tovább fut, eredmények felhasználása (10,11)
55
A rendszerhívás lépései
read (fd, buffer, nbytes)
56
Példák rendszerhívásokra
57
4.2 Fontosabb rendszermodulok
• Folyamatok kezelése
• Központi tár kezelése
• Perifériák kezelése
• Állományok kezelése
• Védelmi mechanizmusok
• Hálózatok kezelése
• Kezelői felület
58
Folyamatok kezelése 1.
• Folyamat = végrehajtás alatt álló program
(dinamikus)
• A program (statikus) egyszerre több
folyamatból áll.
• Felhasználói folyamatok
– egy munkafázis elindulásakor jönnek létre
• Rendszer folyamatok
– a rendszer indulásakor keletkeznek.
• Folyamatok más folyamatokat hozhatnak
létre.
59
Folyamatok kezelése 2.
Problémák
• Folyamatokhoz erőforrások biztosítása
– Folyamat indulásakor allokálódnak, vagy
amikor szükség van rá.
• Holtpont a folyamatok között (kölcsönös
várakozás).
• CPU mint erőforrás a folyamatok közötti
megosztása (CPU ütemezés).
60
Folyamatok kezelése 3.
Folyamatokat kezelő rendszerhívások:
61
Központi tár kezelése
• Folyamathoz annak indulásánál (esetleg
később is) memóriát kell rendelni.
• Virtuális tárkezelés
– virtuális cím - közvetlen cím hozzárendelés
• Központi tárban több folyamat utasításai,
adatai vannak. Ezért biztosítani kell, hogy
– a futáshoz szükséges részek az operatív tárban,
– a nem szükségesek pedig a háttértáron legyenek.
62
Perifériák kezelése
• Perifériák elrejtése a programok elől.
• Átvitel pufferelése
– CPU jobb kihasználása érdekében.
• Periféria (HD) jobb kihasználása
érdekében több egyidejű igény
ütemezése.
63
Állományok kezelése
Fájl (file):
– egymáshoz tartozó információk gyűjteménye
– elrejti a tárolás részleteit.
• Tárolja a felhasználói programokat és adatokat.
• állományok csoportosítása könyvtárakban
(hierarchia)
• állományok létrehozása, megszüntetése, olvasása,
írása, stb., valamint a szabad hely nyilvántartása.
• Megbízható mentés (backup).
64
Állományok felépítése
65
Állománykezelő rendszerhívások
66
Védelmi mechanizmusok
• OS-t és erőforrásait védeni kell a hibás
vagy illetéktelen felhasználásoktól.
• Lehet
– hardver, vagy
– OS-ben megvalósított
védelmi mechanizmus
67
Hálózatok kezelése
• Távoli felhasználókkal, gépekkel való
kommunikáció,
• távoli erőforrások elérése.
68
Kezelői felület
•
OS és a felhasználó kommunikációja.
– Programok indítása, interaktív információcsere
• Parancsértelmező, parancsnyelv (karakteres
kommunikáció)
• Grafikus, speciális beviteli eszközökkel
megvalósított kommunikáció.
• Felhasználói programokra egységes eszközök,
rendszerhívások, ezek használatát szabályozó
ajánlások.
69
4.3 Az operációs rendszerek szolgáltatásai
• Folyamatok vezérlése
• Állományok kezelése
• Perifériás eszközök kezelése
• Rendszerinformációk kezelése
• Kommunikáció
70
Folyamatok vezérlése
• program betöltése, végrehajtása
• folyamatok létrehozása, megszüntetése;
attribútumainak beállítása;
• központi tár igénylése, felszabadítása;
• folyamatok közötti kommunikáció,
folyamatok szinkronizálása (egymáshoz,
órához, külső eseményhez);
• nyomkövetés hibakereséshez
71
Állományok kezelése
• állomány létrehozása, törlése,
attribútumok beállítása;
• könyvtárak létrehozása, módosítása;
• állományok megnyitása, lezárása,
szekvenciális és véletlen átvitel .
72
Perifériás eszközök kezelése
• Perifériák
– igénylése;
– lefoglalása;
– felszabadítása;
• Adatátvitel a program és a periféria
között
73
Rendszerinformációk kezelése
• A rendszerkomponensek
– folyamatok
– állományok
– perifériák
állapotának lekérdezése, módosítása;
• rendszer statisztikák, naplózás
74
Kommunikáció
• kommunikációs csatornák
– létrehozása
– megszüntetése;
• üzenetek
– küldése
– fogadása;
• műveletek távoli erőforrásokon.
75
4.4 Rendszerprogramok
Az OS-hez adott, annak általános célú
felhasználását támogató programok.
• parancsértelmező
• állományrendszer kezelő
• szövegszerkesztő
• fordító program, linker, loader, könyvtár
kezelő
• kommunikációs programok (pl. levelezés)
Operációs rendszerek
2. Folyamatok
Felhasznált irodalom:
• Kóczy-Kondorosi (szerk.): Operációs rendszerek mérnöki megközelítésben
• Tanenbaum: Modern Operating Systems 2nd. Ed.
• Silberschatz, Galvin, Gagne: Operating System Concepts v2.0
2
2. Folyamatok
• Bevezetés
• Folyamatkezelés multiprogramozott
rendszerben
• Környezet váltás
• Folyamatleírók, I/O leírók
• Szálak
• Megszakítások
3
Bevezetés
• A folyamat (process) a
multiprogramozott OS rendszerek
alapfogalma:
végrehajtás alatt álló program.
4
Folyamatok
Multitaszkos rendszerben több folyamat
van a rendszerben egyidejűleg.
Elnevezések:
– munka (job) - batch rendszereknél
– feladat (taszk) - real time
– felhasználó - időosztásos rendszereknél
• Általános a
folyamat név.
5
2.1. Folyamatkezelés
multiprogramozott rendszerekben
• Folyamatok modellezése
multiprogramozott környezetben
• Folyamatok állapotgráfja
• Az állapotok és állapotátmenetek
• Kibővített állapotgráf
6
Folyamatok modellezése
a) Multiprogramozott rendszer (1 PC)
b) Valódi párhuzamos rendszer (4 PC)
c) Folyamatok időbeli eloszlása multiprogramozott
rendszerben
7
Folyamatok állapotai
• Több folyamat , 1 CPU  látszólagos
párhuzamosság.
• CPU kitüntetett erőforrás, egy adott pillanatban csak
1 program hajtódik végre.
• Gráffal lehet ábrázolni. Állapotok:
– Fut: A CPU a folyamathoz tartozó utasításokat hajtja végre,
CPU-nként egyetlen ilyen folyamat lehet.
– Várakozik, blokkolt: A folyamat várakozni kényszerül,
működését csak valamilyen esemény bekövetkezésekor tudja
folytatni. Több ilyen is lehet a rendszerben.
– Futásra kész: Minden feltétel adott, a CPU éppen foglalt.
Több ilyen is lehet a rendszerben.
8
Folyamatok állapotai
Folyamatok állapot-átmeneti gráfja
Futásra
kész Várakozik
Fut
létrejön
elindul
futás
megszakad
esemény
bekövetkezik
eseményre vár
megszűnik
9
Folyamatok állapotátmenetei
• Folyamat létrehozása
• Folyamat befejeződése
• Eseményre vár
• Esemény bekövetkezik
• Folyamat elindul
• Futás megszakad
10
Mikor jön létre egy folyamat?
• Rendszer elindításakor (boot)
– Pl. felhasználói interfészek, démonok
• Folyamatot létrehozó rendszerhívás hatására ( pl. fork )
– Egy folyamat gyermek folyamatot hozhat létre
• Hierarchia (UNIX): „process group”
• Minden folyamat egyenlő (Windows)
• Felhasználó
– Program indítása
• Új batch-job indítása
– Kötegelt rendszereknél OS dönti el, mikor kezdhet futni egy
új munka
Futásra
kész Várakozik
Fut
létrejön
elindul
futás
megszakad
esemény
bekövetkezik
eseményre vár
megszűnik
Folyamat létrehozása 1.
11
• Létrehozó folyamat:
szülő,
a létrejöttek a
gyerekek.
• Leszármazási reláció, hierarchikus struktúra.
• Erőforrás kell neki
– OS-től kapja
– szülő erőforrásain osztozik
• Szülőtől paramétereket kap (befolyásolja a futását)
• Gyerek a szülővel párhuzamosan fut, vagy bevárja a
gyerekének, gyerekeinek befejeződését.
• Szülő azonosítja a gyerekét.
Futásra
kész Várakozik
Fut
létrejön
elindul
futás
megszakad
esemény
bekövetkezik
eseményre vár
megszűnik
Folyamat létrehozása 2.
12
Példa:
UNIX folyamat-hierarchia
Futásra
kész Várakozik
Fut
létrejön
elindul
futás
megszakad
esemény
bekövetkezik
eseményre vár
megszűnik
Folyamat létrehozása 3.
13
• Önszántából
– végrehajtotta utolsó utasítását
– hiba miatt leáll
• OS vagy rokon (általában a szülő) leállítja
– Hibás utasítás, erőforrás használat túllépése
– kill utasítás (másik folyamat)
• Erőforrások felszabadulnak
– attól függően, hogy kitől kapta: felszabadul vagy szülőhöz
kerül
• Szülőnek információt adhat vissza.
Futásra
kész Várakozik
Fut
létrejön
elindul
futás
megszakad
esemény
bekövetkezik
eseményre vár
megszűnik
Folyamat befejeződése
14
• Fut  várakozik
• Valamit kér, amire várnia kell
– jelzés,
– erőforrás, stb.
• OS feljegyzi, hogy ki mire vár.
• Több folyamat is várhat ugyanarra.
Futásra
kész Várakozik
Fut
létrejön
elindul
futás
megszakad
esemény
bekövetkezik
eseményre vár
megszűnik
Eseményre vár
15
• Várakozik  futásra kész
• A várt esemény bekövetkezett
• Még nem fut!
Futásra
kész Várakozik
Fut
létrejön
elindul
futás
megszakad
esemény
bekövetkezik
eseményre vár
megszűnik
Esemény bekövetkezik
16
• Futásra kész  fut
• ha a CPU felszabadul,
egy folyamat
futhat
• kiválasztás kritériumok alapján (CPU
ütemezés)
Futásra
kész Várakozik
Fut
létrejön
elindul
futás
megszakad
esemény
bekövetkezik
eseményre vár
megszűnik
Folyamat elindul
17
• Fut  futásra kész
• Önként lemond a CPU-ról.
– Pl. kooperatív viselkedés: hosszú feladatok esetén
újraütemezést kér.
• OS elveheti a CPU-t, még akkor is, ha a
folyamat egyébként nem kényszerül
várakozásra (
preemptív ütemezés)
– Pl. időosztásos rendszerek. Túl sok ideje futott.
Óra megszakítás jelzi az eseményt.
Futásra
kész Várakozik
Fut
létrejön
elindul
futás
megszakad
esemény
bekövetkezik
eseményre vár
megszűnik
Futás megszakad
18
Folyamatok kibővített állapotai
• Bővítés: az OS felfüggeszthet folyamatokat
(középtávú CPU ütemezés)
– a rendszer túl van terhelve (sok program vetélkedik a futás
jogáért, vagy a tár túlzottan megtelt, stb.)
– vészhelyzet esetén
– felhasználó kezdeményezésére
• A felfüggesztett folyamatok erőforrásaikat elvesztik
(de a rendszer számon tartja őket, később
folytatódhatnak)
• Két új állapot:
– felfüggesztve vár
– felfüggesztve futásra kész
19
Folyamatok kibővített állapot-átmeneti gráfja
Futásra
kész Várakozik
Fut
létrejön
elindul
futás
megszakad
esemény
bekövetkezik
eseményre vár
megszűnik
Felfüggesztve
várakozik
Felfüggesztve
futásra kész
aktivál
felfüggeszt
esemény
bekövetkezik
Aktív
állapotok
Passzív
állapotok
felfüggeszt
20
Új állapotátmenetek
• Felfüggeszt
– OS felfüggeszti (futásra kész vagy várakozik állapotból)
– erőforrásokat elveszi (pl. memória), néhányat megtarthat (pl.
nyomtató)
• Aktivál
– Erőforrásokat visszaad
• Felfüggesztve várakozik  felfüggesztve
futásra kész
– Esemény bekövetkezik, de CPU-t nem kaphat
• A felfüggesztve vár  várakozik átmenetnek nincs
értelme (tovább várakozna, de lekötné az
erőforrásokat)
21
• Rövidtávú
– ki kapja meg a CPU-t
• Középtávú
– pillanatnyi túlterhelés megszüntetése
• Hosszútávú
– A multiprogramozás mértékének meghatározása
Ütemezés Futásra
kész Várakozik
Fut
létrejön
elindul
futás
megszakad
esemény
bekövetkezik
eseményre vár
megszűnik
Felfüggesztve
várakozik
Felfüggesztve
futásra kész
aktivál
felfüggeszt
esemény
bekövetkezik
Aktív
állapotok
Passzív
állapotok
felfüggeszt
22
• Minden rendszer
– méltányosság
– szabálykövetés
– kiegyensúlyozottság
• Kötegelt rendszerek
– áteresztőképesség
– körülfordulási idő
– CPU kihasználtság
• Interaktív rendszerek
– válaszidő
– arányosság
• Valós idejű rendszerek
– határidők betartása
– kiszámíthatóság
Ütemezés
23
2.2 Környezetváltás
• Környezet váltás (kontext switch):
– a futó folyamat elhagyja a futó állapotot,
– egy futásra kész pedig elindul.
• Az átkapcsolás zökkenőmentes legyen:
állapotleírókat meg kell őrizni
1. folyamat állapota
2. végrehajtó gép állapota
• Multiprogramozásnál fontos a gyors
átkapcsolás (hatékonyság).
24
A folyamat állapota
Állapotváltozók:
• programkód
• változók aktuális értéke
• verem tartalma
• hol tart a program végrehajtása (programszámláló)
– ezt a végrehajtó gép tartalmazza!
• Tárban több folyamat van, így a folyamatok
állapotleírói megmaradnak a tártartalom
megőrzésével.  Csak a
végrehajtó gép állapotát kell
menteni.
25
A végrehajtó gép állapota
• A végrehajtó gép a folyamat környezete, a gép
állapotleíróinak összességét kontextusnak nevezzük.
• A rendszer rétegszerkezete miatt több szintű. A
legegyszerűbb eset, amikor a folyamat kódja csak
gépi utasításokat tartalmaz  hardver-szoftver
határfelület
• Legtöbbször az OS alapszolgáltatásait is tartalmazó
virtuális gép határfelülete.
– CPU regiszterek
– OS változók
• rendszertáblák,
• memóriakezelési információk,
• periféria hozzárendelések, stb.
26
2.3 Folyamatleírók, I/O leírók
• Speciális adatszerkezetek
• Az OS-nek a folyamatok és az I/O
egységek kezeléséhez szükséges
adatait tárolja
– Process Control Block, PCB
– Input Output Control Block, IOCB
27
Folyamatleíró blokk
Process Control Block, PCB:
– folyamat azonosítója
– szülők, gyerekek azonosítója
– folyamat állapota
– folyamathoz tartozó összes tárterület leírása (mutatók,
virtuális tárkezeléshez tartozó adatok, cím transzformáció)
– a folyamat által használt egyéb erőforrások leírása (pl.
nyitott állományok)
– regiszterek tartalma
– várakozó folyamatoknál: várt esemény leírása
– ütemezéshez információk (prioritás, várakozási idő)
– statisztikák
28
Folyamatleírók kezelése
Láncolt listák:
• Futó folyamat
• Futásra kész folyamatok
PCB4
PCB1 PCB3 PCB5
29
I/O műveletek leírása
Input Output Control Block, IOCB:
• Az I/O művelet végrehajtásához tartozó
minden adat:
– művelet kijelölése (írás, olvasás, ...)
– tárterület címe (ahonnan, ahova a művelet
végrehajtandó)
– I/O készülék egyéb adatai (mágneslemez
szektorcíme, stb.)
– átviendő adatmennyiség
– állapotjelző
30
I/O leírók kezelése
Az IOCB a PCB-hez fűződik:
• 1. periféria várakozási sora
• 2. periféria várakozási sora
PCB7 PCB2
IOCB7 IOCB2
PCB6
IOCB6
31
I/O műveletek végrehajtása
Folyamat:
– Kitölti az IOCB-t
– Rendszerhívás, paraméter az IOCB
OS
– Láncolja az IOCB-t a PCB-hez
– PCB-t befűzi a periféria várakozási sorába
– Ha a sor üres, indítja a perifériát az IOCB paramétereivel
– Folyamatot várakozó állapotba teszi
– Újraütemez és visszatér (másik folyamatra)
Periféria
– Feladat végeztével megszakítást okoz
OS
– IOCB-be a végrehajtás eredményére utaló jelzést ír (helyes/helytelen)
– PCB-t a futásra kész állapotba helyezi
– Ha van még várakozó a perifériára, akkor a perifériát indítja
– Újraütemez
– Visszatér
32
I/O műveletek végrehajtása
Folyamatok OS Perifériák
futvárakozikfut futásra kész
IT
elindít
elindít
rendszerhívás
ütemezés
ütemezés
33
2.4 Szál (thread)
• Folyamatokhoz hasonló fogalom
• Nincs saját memória, saját erőforrás
– csak a
regiszterek és a
verem sajátja (+állapot)
–
minden más közös a folyamatával
• Előny:
– Gyors váltást tesz lehetővé
– Osztott erőforrások (memória!) lehetősége
•
Állapot-átmeneti gráfja megegyezik a
folyamatoknál tárgyalttal.
34
Szálak és folyamatok 1.
Minden folyamatnak van:
Címtér
Globális változók
Megnyitott fájlok
Gyermek folyamatok
Várt események listája
...
Minden szálnak van:
Programszámláló
Regiszterek
Stack
Állapot
35
Szálak és folyamatok 2.
a) Három folyamat egy-egy szállal
b) Egy folyamat három szállal
36
Példa: szövegszerkesztő
• Billentyűzet-kezelő szál
• Tördelő szál
• Automatikus mentés szál
37
Példa: web-szerver 1.
•
Dispatcher szál: fogadja a kérést és kiosztja a munkát
•
Worker szál: teljesíti a kérést
38
Példa: web-szerver 2.
a)
Dispatcher szál
b)
Worker szál
39
Felbukkanó (pop-up) szálak
a) Üzenet megérkezése előtt
b) Üzenet megérkezése után
40
2.5 Megszakítások
• Interrupt
• Osztályai:
– perifériák (berendezések állapotának változásai,
átvitel befejezése)
– belső hardver (timer)
– utasítás végrehajtási hiba (pl. 0-val való osztás,
memória hiba, virtuális tárkezelésben laphiba,
stb.)
– hardver hiba (pl. tápfeszültség)
– szoftver megszakítás (trap), speciális gépi utasítás
pl. rendszerhívás
41
Prioritás
• Nem minden megszakítás azonos súlyú
– pl. egy magasabb megszakíthat egy
alacsonyabb prioritású kiszolgálást
• Megszakítások letilthatók /
engedélyezhetők
– csak korlátozott ideig hiszen pl. a
perifériáknál az átvitelkor adatok
veszthetnek el).
42
Megszakítások kezelése
1. Nincs környezet váltás.
• Megszakítás hatására OS rutin indul el,
folyamat felfüggesztve, csak a kiszolgáló
rutin által használt regisztereket mentjük el
(ezek általában rövid kis programok).
2. Van környezet váltás (ritkábban, lassabb).
• A megszakítás elindít egy arra váró
folyamatot. A folyamat várakozóból rögtön
futni fog (elkerüli a futásra kész állapotot).
43
Megszakításkezelés lépései
• A futó folyamat megszakad, vezérlés az OS-nek
• Megszakított folyamat állapotmentése
(1. vagy 2. módban)
– pl. regiszterek mentése (van HW támogatás)
• Vezérlést a kiszolgáló rutin kapja meg
• Befejezés után állapot visszaállítás
(1. vagy 2. mód)
• Megszakított - vagy egy másik - folyamat folytatja a
futását.
44
Megszakításkezelés támogatása
• Megszakításkezelést hardver támogatja
• A megszakított folyamat folytatásához
ad segítséget
– automatikus regiszter mentés,
visszatöltés, folyamatok állapotainak
megváltoztatása.
Operációs rendszerek
3. Folyamatok kommunikációja
Felhasznált irodalom:
• Kóczy-Kondorosi (szerk.): Operációs rendszerek mérnöki megközelítésben
• Tanenbaum: Modern Operating Systems 2nd. Ed.
• Silberschatz, Galvin, Gagne: Operating System Concepts v3.0
2
Tartalom
• Bevezetés
• Szinkronizáció
• A kritikus szakasz megvalósítási
módozatai
• Információcsere folyamatok között
3
3.1 Folyamatokból álló rendszerek
Egy rendszer több folyamatból állhat. Ezek között
csatolás lehet:
• független folyamatok
– egymás működését nem befolyásolják,
– aszinkron működés
• egymással párhuzamosan is végrehajtódhatnak,
• nincs időbeli függőség
• függő folyamatok,
– logikailag független folyamatok, de megosztott erőforrás
használat (pl. több felhasználó, azonos gépen dolgozik)
– logikailag függő folyamatok
• közösen oldanak meg valamely feladatot
• együttműködnek, kommunikálnak, közös változók, stb.
4
Együttműködő folyamatok használatának indokai
• Erőforrások megosztása
– átlapolt működés, jobb kihasználtság
• Számítások felgyorsítása (több processzor)
– Számítások párhuzamosítása, végrehajtási sebesség nő
• Felhasználók kényelme
– Egy időben több feladat megoldása
• Modularitás
– Egy adott folyamat kisebb részekre való bontása
– Jobb áttekinthetőség
– Bizonyos feladatoknál (párhuzamos részek) kézenfekvő
modell.
– Pl. vezérlés, folyamatirányítás
– A függőséget valahogy biztosítani kell
5
3.2 Szinkronizáció
• Egy folyamat végrehajtásának olyan időbeli
korlátozása, ahol az egy másik folyamat futásától
illetve egy külső esemény bekövetkezésétől függ.
• Gyakori feladatok:
– Precedencia (előidejűség)
– Egyidejűség
– Kölcsönös kizárás (versenyhelyzet, kritikus szakasz)
• Egyéb kapcsolódó fogalmak:
– Holtpont (deadlock)
6
Precedencia
• Meghatározott sorrend biztosítása.
• Egy
Pk folyamat
S k utasítása csak akkor
mehet végbe ha a
Pi folyamat
S i
utasítása már befejeződött.
• pl:
szakács-kávét főz  kukta-cukrot vesz
(különben kihűl a kávé)
7
Egyidejűség
• Két vagy több folyamat bizonyos utasításait
(
S k ; S j) egyszerre kell elkezdeni.
• Két folyamat találkozása (randevú).
• Két folyamat bevárja egymást mielőtt további
működését elkezdené.
• pl.
szakács-kávét főz || kukta-habot ver
(különben kihűl a kávé vagy összeesik a hab)
8
Kölcsönös kizárás (mutual exclusion)
• A résztvevő folyamatok utasításainak
sorrendjére nincs korlátozás, de egy
időben csak egyik futhat.
• pl.
szakács-habot ver X kukta-habverőt
mosogat
9
Versenyhelyzet
• Több párhuzamosan futó folyamat közös erőforrást
használ. A futás eredménye függ attól, hogy az egyes
folyamatok mikor és hogyan futnak, ezáltal hogyan
(milyen sorrendben) férnek az erőforráshoz.
• Elkerülendő, nagyon nehéz debuggolni!
• Példa:
A mért hőmérséklet (T) értékét egy két szó
hosszúságú változóban (TK) tároljuk. A hőmérő
folyamat a hőmérsékletet szavanként beírja a
változóba, a szabályzó folyamat pedig kiolvassa a
változót és annak értékét használja.
10
Példa versenyhelyzetre: hőmérséklet-szabályzó
*Ha ebben a pillanatban olvas, hibás, inkonzisztens értéket kap.
03
02
Hőmérő
folyamat Szabályzó folyamat
02
98
(T=298ºC) (régi TK=302ºC)
hőmérő
03
98
Hőmérő
folyamat Szabályzó folyamat
02
98
02
98 Szabályzó folyamat
02
98
Hőmérő
folyamat
Írás: alsó szó
Írás: felső szó
*
(új TK=298ºC)
idő
11
Kritikus szakasz
• Kritikus szakaszoknak nevezzük a program olyan
(általában osztott változókat használó)
utasításszekvenciáit, amelyeknek egyidejű
(párhuzamos) végrehajtása nem megengedett.
• Versenyhelyzet elkerülésére a kritikus szakaszok
kölcsönös kizárását biztosítani kell.
(Ha az egyik folyamat már a kritikus szakaszában
van, akkor más folyamat nem léphet be a
(természetesen saját) kritikus szakaszába.)
• Pl.
Tipikus kritikus szakasz a közös memória használata.
12
Példa kritikus szakaszra: hőmérséklet-szabályzó
Kritikus szakaszok
Hőmérő
folyamat
...
Hőmérő leolvasása
Írás: alsó szó
Írás: felső szó
...
Szabályzó
folyamat
...
Olvasás: alsó szó
Olvasás: felső szó
Számítás
...
13
Kritikus szakaszok és a kölcsönös kizárás
A kritikus szakaszban lévő
A folyamat blokkolja
B végrehajtását,
amikor az is a kritikus szakaszba kíván lépni (T 2 ). Amikor
A kilép
a kritikus szakaszból (T 3 ), a blokkolás véget ér és
B most már
beléphet a kritikus szakaszba.
A belép a kritikus szakaszba
A kilép a kritikus szakaszból
B próbál belépni
a kritikus szakaszba
B belép a
kritikus szakaszba
B kilép a
kritikus szakaszból
B blokkolt
T 1 T 2 T 3 T 4
14
3.3 A kritikus szakasz megvalósítási kritériumai
A megvalósítás követelményei
1. Biztosítsa a kölcsönös kizárást
– Egy időben csak egyetlen folyamat hajthatja végre a kritikus
szakaszban lévő utasításokat.
2. Haladjon
– Ha nincs folyamat a kritikus szakaszban, de van több belépő, akkor
az algoritmus ezek közül véges idő alatt kiválaszt egyet és
beengedi a kritikus szakaszba.
3. Folyamat várakozása korlátozott legyen (ne éheztessen)
– Csak véges számú esetben előzhetik meg.
• A 3. kritériumot nem veszik annyira szigorúan (nem minden
algoritmus teljesíti).
15
Kritikus szakasz megvalósítása
A folyamat általános struktúrája:
//Process i
while (TRUE){
non_critical_region1();
entry_section();
critical_region(); //nem kell függvény legyen
exit_section();
non_critical_region2();
}
16
Kritikus szakasz megvalósítási módozatai
• Interrupt tiltása
•
Busy waiting megoldások
– Nincs HW támogatás, tiszta SW megoldás.
• Naiv megközelítés (ROSSZ)
• Strict alternation (JOBB)
• Peterson algoritmusa (HELYES)
– HW támogatással:
• TestAndSet
• Szemafor
• Magas szintű módszerek
17
Interrupt tiltása
• Megoldás:
disable_interrupt();
critical_region();
enable_interrupt();
• Egyszerű megoldás:
– Nincs IT, tehát nem lehet a végrehajtást megszakítani.
(Ütemező sem tud futni!)
• Probléma:
– A folyamatnak joga van letiltani az IT-t. Az egész rendszert
lefagyaszthatja.
• Hasznos az OS szintjén
• Nem célszerű a felhasználói szinten.
18
Naiv programozott megközelítés
• Közösen használt változókon (flag) alapul.
• Egy foglaltsági bitet használ, amit a belépni kívánó
folyamat tesztel.
• Gond: a változót többen is olvashatják, mielőtt az
első foglaltra állítja!
//Process 0
while (TRUE){
while (flag!=0) /*loop*/;
flag = 1;
critical_region();
flag = 0;
non_critical_region();
}
//Process 1
while (TRUE){
while (flag!=0) /*loop*/;
flag = 1;
critical_region();
flag = 0;
non_critical_region();
}
19
Szigorú váltás (
strict alternation)
algoritmus
• Közös változó:
turn. Jelentése: ki van soron.
• Csak felváltva lehet belépni.
• Gond:
– Ha jelentős a sebességkülönbség, akkor az egyik feleslegesen
sokat vár.
– Nem halad!
//Process 0
while (TRUE){
while (turn!=0) /*loop*/;
critical_region();
turn = 1;
non_critical_region();
}
//Process 1
while (TRUE){
while (turn!=1) /*loop*/;
critical_region();
turn = 0;
non_critical_region();
}
„Spin
lock”
20
Peterson algoritmusa 1.
define FALSE 0
define TRUE 1
define N 2 /* a folyamatok száma */
int turn; /* ki van soron? */
int interested[N]; /* kezdetben csupa 0 */
void enter_region(int process); /* a folyamat belép a kritikus szakaszba*/
{
int other;
other = 1 – process; /* a másik folyamat */
interested[process] = TRUE; /* az érdeklődés jelzése */
turn = process; /* flag beállítása */
while (turn == process && interested[other] == TRUE) /* nop */;
}
void leave_region(int process); /* a folyamat elhagyja a kritikus szakaszt */
{
interested[process] = FALSE;
}
21
Peterson algoritmusa 2.
• Ha csak egy folyamat akar belépni, az
enter_region() visszatér és a folyamat a kritikus
szakaszba léphet.
• A másik folyamat addig nem léphet be, amíg a
leave_region() az interested változót nem
törli.
• Ha két folyamat egyszerre akar belépni, a turn
változót utoljára állító folyamat várakozik, míg a
másik végre nem hajtja a saját leave_region()
eljárását.
• Megjegyzés: A turn változó írásának
megszakíthatatlanak kell lenni (ez könnyen
teljesíthető).
22
Hardver támogatás kritikus
szakasz megvalósításához
• Speciális megszakíthatatlan gépi utasítások
1. TestAndSet
– Kiolvassa és visszaadja a bit értéket, majd azonnal 1-be állítja.
int TestAndSet(int *flag){
tmp = *flag;
*flag = 1;
return(tmp)
}
2. Swap
– Két változó értékét cseréli fel
void swap(int *a, int *b){
tmp = *a;
*a = *b;
*b = tmp;
}
oszthatatlan
oszthatatlan
23
Kritikus szakasz TestAndSet
utasítással
//init
flag = 0;
...
//Process i
while (TRUE){
while (TestAndSet(&flag)!=0) /*empty loop*/;
critical_region();
flag = 0; /*exit critical section*/
non_critical_region();
}
• Nem garantálja az éhezés kiküszöbölését!
24
Kritikus szakasz swap utasítással
//init
flag = 0;
...
//Process i
...
while (TRUE){
myflag = 1;
while (myflag!=0) swap(&myflag, &flag);
critical_region();
flag = 0; /*exit critical section*/
non_critical_region();
}
• Nem garantálja az éhezés kiküszöbölését!
25
Szemafor
E. W. Dijkstra, 1965
• Speciális adattípus (nemnegatív egészek),
• Az
s szemafor-változó két oszthatatlan utasítással
érhető el:
• P(s) - vizsgál/belép művelet
– Működési elv:
while s < 1 do üres utasítás;
s := s – 1
• V(s) – kilép művelet
– Működési elv:
s := s + 1
26
Mutex
• A mutex olyan speciális szemafor,
amelynek csak két értéke lehet:
– nyitott (unlocked)
– zárt (locked)
• Műveletei:
– mutex_lock
– mutex_unlock
27
Szinkronizáció szemaforral
• Előidejűség (
U 1 előbb mint
U 2 )
s := 0
P1 : ... U 1; V(s); ...
P2 : ... P(s); U 2; ...
• Randevú (
U 1 és
U 2 egyszerre)
s1 := 0; s 2 := 0
P1 : ... V(s1); P(s2 ); U1 ; ...
P2 : ... V(s2); P(s1 ); U2 ; ...
• Kölcsönös kizárás
s := 1
P1 : ... P(s); U 1; V(s); ...
P2 : ... P(s); U 2; V(s); ...
– Az
s kezdő értékétől függ, hogy hány folyamat lehet egyszerre a
kritikus szakaszban. Legtöbbször bináris szemafort (mutex)
használunk.
28
Szemaforok megvalósítása
• Probléma a szemafor elvi megvalósításával: busy
waiting
P(s):
while s < 1 do üres utasítás;
s := s – 1
– Ez blokkolt állapotban is állandóan futna, állandóan
használná a CPU-t. Így nem használható.
• Multiprogramozott megoldás:
– A
P(
s) az üres utasítás helyén a folyamattól elveszi a CPU-t
és várakozó állapotba teszi (feljegyzi a szemaforhoz tartozó
valamilyen adatszerkezetekbe).
– A
V (
s)-nél nem csak a számláló nő, hanem egy folyamatot
(ha van) futásra kész állapotba tesz (többféle stratégia
lehet).
29
Szemaforok megvalósítása
type semaphore = record
value: integer
list : list of process
end; s
P(s):
s:value := s:value - 1
if s:value < 0 then
begin
a folyamat felfűzése a s.list-re
a folyamat felfüggesztése, újra ütemezés
end
V(s):
s:value := s:value + 1
if s:value <= 0 then
begin
leveszünk egy folyamatot s:list -ről
felébresztjük ezt a folyamatot
end
30
Monitor
• A szemafor hasznos szinkronizációs eszköz, de
alacsony szintű.
– Sok hibalehetőség, ráadásul nehéz a hibakeresés.
• Nyelvi elemekkel való támogatás:
monitor, egy
magas szintű szinkronizációs primitív.
• A monitor eljárások, változók, adatszerkezetek
speciális gyűjteménye.
• A monitor eljárásai szabadon hívhatóak, de a
változókhoz nem lehet kívülről közvetlenül hozzáférni.
• Egyszerre csak egy eljárás lehet aktív a monitoron
belül!
31
Monitor példa
• Egyszerű monitor példa:
• Csak a
producer és a
consumer eljárások
láthatók
• Az
i és
c belső változókat
csak a belső eljárások
kezelhetik
• Legfeljebb egy eljárás
lehet aktív: vagy a
producer, vagy a
consumer
monitor example
integer i;
condition c;
procedure producer();
end;
procedure consumer();
end
end monitor;
32
Az akadály (barrier)
a) Több folyamat (A, B, C, D) szinkronizálására szolgál
b) Az akadályt elérő folyamatok blokkolódnak
c) Az összes folyamat megérkezésekor az akadály ledől, az összes
folyamat egyszerre folytatja futását.
Barrier
A
B
C
D
Barrier
A
B
C
D
Barrier
A
B
C
D
33
3.4 Információcsere folyamatok
között
• Folyamatok együttműködéshez információ
cserére (interprocess communication) van
szükség.
• Alapvetően két mód:
– közös tárterületen keresztül (szorosan csatolt)
(kölcsönös kizárás témaköre)
– kommunikációs csatornán keresztül (lazán csatolt)
• Kommunikációs csatorna
– Két folyamat között valamilyen - fizikai, virtuális
(logikai) - csatorna van.
– Egyik folyamat küld, a másik vesz.
34
Kommunikációs csatorna
tulajdonságai
• milyen közeg biztosítja az átvitelt:
– Pl: párhuzamos vagy soros, lokális hálózat,
virtuális esetén közös tár
• kapcsolat egy vagy kétirányú
• kapcsolatot két vagy több folyamat
használhatja
– két folyamat között pont-pont kapcsolat
– ugyanazt a csatornát több folyamat is
használhatja
• egy időben, vagy időmultiplexelt rendszerben
• van-e közbülső tárolás (puffer)
• megbízhatóság
35
Folyamatok megnevezése
(naming)
• Az a módszer, amellyel a
kommunikációban résztvevő folyamatok
egymásra hivatkoznak.
• Közvetlen kommunikáció
• Közvetett kommunikáció
• Aszimmetrikus megnevezés
• Üzenetszórás
36
Közvetlen kommunikáció
• Folyamatok:
P,
Q
• üzenet küldés:
send(
Q; message),
• üzenet fogadás: message=
receive(
P)
;
• csak egy csatorna létezik, és más folyamatok
nem használhatják
P Q
37
Közvetett kommunikáció
• Közbülső adatszerkezeten (pl. postaládán (mailbox)) keresztül
valósul meg.
• Küldés:
send(
mailbox, message);
• Fogadás: message=
receive(
mailbox);
• Két folyamat között lehet több postaláda.
• Ugyanazt a postaládát több folyamat is használhatja
egyidejűleg.
• A postaláda megosztása a vevők között:
– csak két folyamat használhatja
– egy időben csak egy vevő lehet
– a rendszer választ, hogy melyik vevőnek küldi az üzenetet és erről
értesíti az adót.
P Q
mail
38
Aszimmetrikus megnevezés
• Adó vagy vevő megnevezi, hogy melyik folyamattal akar kommunikálni
• A másik fél egy kaput (port) használ, ezen keresztül több folyamathoz,
is kapcsolódhat.
• Tipikus eset: a vevőhöz tartozik a kapu, az adóknak kell a vevő
folyamatot és annak a kapuját megnevezni.
– (Pl. szerver, szolgáltató folyamat)
• Küldés:
send(
Q:port,
message);
• Fogadás: message=
receive();
P Q
39
Üzenetszórás
• A közeg több folyamatot köt össze.
• Az üzenet amelyet több folyamat,
esetleg mindegyik veheti.
• Küldés:
send(
message, to_all);
• Fogadás: message=
receive();
P Q1
Q3
Q2
40
Implicit szinkronizáció
• Folyamatok között információcsere implicit szinkronizációval jár,
ennek típusa a puffertől függ.
• Tárolás nélküli átvitel
– Nincs tárolás, így az adás és vétel egy időben zajlik (randevú).
• Véges kapacitású tároló
– Egy időben csak az egyik folyamat használhatja (kölcsönös kizárás)
– Vevő várakozik, amíg legalább egy elem nincs elküldve;
– adó várakozik, ha a puffer megtelt.
– A két folyamat utasításai között adott sorrendiségnek kell teljesülni
(precedencia).
• "Végtelen" puffer
– Az adó folyamat nem várakozhat (pl. külső folyamat, amelyre az
OS-nek nincs hatása).
– A valóságban természetesen a puffer véges, így megtelhet.
– Ilyenkor információvesztés: új adat figyelmen kívül hagyása vagy
régi adat felülírása a pufferben.
41
Átviteli hibák kezelése
• Elosztott rendszer hibája
– Folyamat befejeződése: adó vagy vevő
folyamat váratlanul befejeződik
• Csatorna hibája
– Elveszett, torzult üzenetek
42
Elosztott rendszer hibája
Adó folyamat áll le
– A vevő hiába várakozik a következő üzenetre.
– Nem holtpont (csak egy folyamatot érint).
– Felismerése: timeout.
– Feloldása: az OS terminálhatja a vevőt vagy jelzi neki az adó
megszűnését.
• Vevő folyamat áll le
– Az adó nulla vagy véges kapacitású puffer esetén várakozni
kényszerül, megoldás az előzőekhez hasonló
– Végtelen puffer esetén az adó az esetleges nyugták megszűnéséből
veheti észre a vevő megszűnését.
• Timeout:
– egy időkorlát túllépése (az az időtartam, amelyen belül valaminek
biztosan történnie kell)
– nehéz megállapítani.
43
Csatorna hibája
• Elveszett, torzult üzenetek
• Az OS felismeri és újraküldi
• Az OS felismeri, az adót értesíti, így az újraküldi
• Vevő ismeri fel, az adót értesíti, így az újraküldi
• Torzult üzenetek felismerése egyszerű (HW vagy SW)
– CRC (Cyclic Redundancy Codes)
– checksum (pl: összeg mod 256)
– ECC (Error Correcting Codes).
• Elveszett üzenetek detektálása bonyolultabb eljárás,
pl. időkorlátok figyelése.
Operációs rendszerek
4. A holtpont és kezelése
Felhasznált irodalom:
• Kóczy-Kondorosi (szerk.): Operációs rendszerek mérnöki megközelítésben
• Tanenbaum: Modern Operating Systems 2nd. Ed.
• Silberschatz, Galvin, Gagne: Operating System Concepts v3.0
2
Tartalom
• Bevezetés
– A holtpont kialakulásának szükséges feltételei
– Az erőforrás-használati gráf
• A holtpont kezelése
– holtpont megelőzése
– holtpont elkerülése
– holtpont felismerése és megszüntetése
• Kombinált stratégiák
• Kommunikációs holtpontok
3
Bevezetés helyett...
4
4.1 Holtpont definíciója
Folyamatok egy halmaza akkor van
holtponton, ha a halmaz minden
folyamata olyan eseményre* vár,
amelyet csak egy másik, ugyancsak
halmazbeli (várakozó) folyamat tudna
előidézni.
*Az esemény többnyire egy erőforrás felszabadulását jelenti.
5
A klasszikus példa...
„When two trains approach each other
at a crossing, they shall both come to a
full stop and neither shall start up until
the other has gone.”
Kansas állam törvénye a XX. sz. elejéről
6
Rendszermodell 1.
• A rendszerben véges számú erőforrás áll
rendelkezésre véges számú folyamat számára
• Az erőforrások osztályokba sorolhatók, az egy
osztályon belüli erőforrások azonosak (egy
igénylő folyamat bármelyiket igénybe veheti)
• Az erőforrás lehet
– elvehető (preemptív) [pl. CPU, memória]
– nem elvehető (nem preemptív) [pl. nyomtató]
7
Rendszermodell 2.
• Erőforrás használata
1. Igénylés. Ha az igény nem teljesíthető (erőforrás foglalt)
akkor a folyamat várakozik.
2. Felhasználás. A folyamat az erőforrást kizárólagosan
használja.
3. Felszabadítás. Folyamat elengedi az erőforrást. Ha más
folyamatok várakoznak rá, akkor valamelyik várakozó
folyamat továbbléphet.
• Az 1. és 3. lépések általában rendszerhívások
• request – release (device)
• open – close (file)
• allocate – free (memory)
8
4.2 Holtpont kialakulásának szükséges feltételei
Holtpont akkor jöhet létre, ha az alábbi négy feltétel
egyszerre teljesül
• Kölcsönös kizárás
– Egy erőforrást egyszerre legfeljebb egy folyamat használhat.
• Foglalva várakozás
– Van olyan folyamat, amely lefoglalva tart erőforrásokat,
miközben más erőforrásokat kér (és azokra várakozik).
• Nem elvehető erőforrások vannak a rendszerben.
– Az erőforrást a folyamat csak önszántából szabadíthatja fel.
• Körkörös várakozás
– Létezik egy olyan {P0 , P1 , ..., Pn} sorozat, amelyben P 0 egy
P1 által lefoglalva tartott erőforrásra vár, P i egy P i+1 által
foglaltra, végül Pn pedig egy P0 által foglalt erőforrásra vár.
9
Teljesülnek a feltételek?
10
4.3 Az erőforrás-használati gráf
• A rendszer pillanatnyi állapotát a rendszer erőforrás-
használati gráfja (resource allocation graph) írja le.
–
P = {
P1 , P2 , ..., Pn }, a rendszer folyamatainak halmaza
–
R = {
R 1 , R 2 , ..., R n }, az erőforrás-osztályok halmaza
–
Pi  R i erőforrás
igénylés
–
R i  Pi erőforrás
használat
• Ha az igény kielégíthető, akkor az erőforrás igénylés
átvált erőforrás használattá.
11
Az erőforrás-használati gráf
• Folyamat
• Erőforrás osztály 4 erőforrással
•
Pi egy
R i osztálybeli erőforrást
igényel
•
Pi egy
R i osztálybeli erőforrást
foglal Pi
Pi
Rj
Rj
12
Példa holtpont kialakulására
A requests R B requests S C requests T
A requests S B requests T C requests R
A:
Requests R
Requests S
Release R
Release S
B:
Requests S
Requests T
Release S
Release T
C:
Requests T
Requests R
Release T
Release R
R S T
A B C
R S T
A B C
R S T
A B C
R S T
A B C
R S T
A B C
R S T
A B C
13
Egy erőforrás-használati gráf
• R 1-et P2 használja
• P1 vár R 1-re
• R 2 egy-egy példányát
használja P1 és P2
• R 4-et nem használják
14
Egy erőforrás-használati gráf holtponttal
• Mindhárom folyamat
vár
• Az igényelt erőforrások
felszabadítását csak
ezen folyamatok
tudnák elvégezni
15
Egy erőforrás-használati gráf körrel, de holtpont nélkül
• Az erőforrásokat P2 és P4
is felszabadíthatja!
•
A kör szükséges és
elégséges feltétel, ha
minden erőforrás-
osztályba csak egy
erőforrás tartozik.
•
Szükséges, de nem
elégséges, ha egy
erőforrás-osztály több
egyedet is tartalmaz.
16
A kör és a holtpont...
• Ha nincs kör, nincs holtpont. (
A kör szükséges
feltétel.)
• Ha van kör és minden erőforrás-osztályba csak
egy erőforrás tartozik, akkor holtpont van.
(
Egyszeres erőforrásoknál a kör elégséges
feltétel is.)
• Ha van kör és egy erőforrás-osztály több
egyedet is tartalmaz, akkor holtpont kialakulhat,
de nem szükségszerűen. (
A kör léte többszörös
erőforrásoknál nem elégséges feltétel.)
17
Példa: holtpont elkerülése
A:
Requests R
Requests S
Release R
Release S
B:
Requests S
Requests T
Release S
Release T
C:
Requests T
Requests R
Release T
Release R
A requests R C requests T A requests S
C requests R A releases R A releases S
R S T
A B C
R S T
A B C
R S T
A B C
R S T
A B C
R S T
A B C
R S T
A B C
18
4.4 A holtpont kezelése
Stratégiák:
1. Strucc algoritmus: nem veszünk tudomást a problémáról és nem
teszünk semmit.
– Bizonyos típusú rendszereknél (nagy kockázat) nem engedhető meg.
– Megengedhető kisebb kockázatú rendszereknél, ahol tolerálható a
„kiszállunk-beszállunk elv”.
– Mérlegelni kell a probléma súlyát és a megoldás árát.
2. Védekezés holtpont kialakulása ellen
– Az erőforrások használatánál bevezetünk szabályokat, ami biztosítja
hogy ne alakuljon ki holtpont.
– holtpont megelőzés (deadlock prevention)
– holtpont elkerülés (deadlock avoidance)
3. Detektálás/feloldás: a holtpont kialakulása után avatkozunk bele
– holtpont felismerés (deadlock recognition)
– holtpont megszüntetés (deadlock recovery)
19
4.5 Holtpont megelőzés (deadlock prevention)
• A holtpont kialakulásnak szükséges feltételek
közül valamelyiket kizárjuk.
– Kölcsönös kizárás
– Foglalva várakozás
– Erőforrások nem elvehetők
– Körkörös várakozás
20
4.5.1 Foglalva várakozás kizárása
Két stratégia:
1. A folyamat elindulásakor egyszerre igényli az összes
szükséges erőforrást. Csak akkor mehet tovább, ha
mindegyiket megkapta.
2. Folyamat csak akkor igényelhet, ha más erőforrást
nem foglal.
• Problémák:
– rossz erőforrás kihasználtság, szükségesnél tovább
birtokolják azokat
– fennáll a kiéheztetés veszélye: ha egy folyamat több
"népszerű" erőforrást használ, nagy az esélye, hogy
egyszerre az összes erőforrást soha nem kapja meg.
• Példa: Számítás szalagról nyomtatóra. Erőforrások:
szalagos tároló – diszk – nyomtató
21
4.5.2 Erőforrások elvétele
Két hasonló stratégia
1. Ha egy folyamat valamely erőforrásigénye nem
elégíthető ki, akkor az összes többit is elvesszük tőle.
Ezekre a továbbiakban várakozik. Akkor futhat
tovább, ha az összes erőforrásigényét egyszerre ki
lehet elégíteni.
2. Ha egy
P folyamatnak olyan erőforrásigénye van,
amelyeket más
várakozó {
Q i } folyamatok foglalnak,
akkor az erőforrásokat
Q i folyamatoktól elveszik és
P
futhat tovább (de csak ha
P összes igénye egyszerre
kielégíthető!), különben pedig
P is várakozik.
• Problémák:
– Az erőforrások egy része csak úgy vehető el, ha közben a
futási eredmények is elvesznek.
– Fennáll a kiéheztetés veszélye.
22
4.5.3 Körkörös várakozás elkerülése
• Rendeljünk a rendszer összes erőforrásához egy
növekvő számsorozat egy-egy elemét.
• Két algoritmus:
1. A folyamatok csak növekvő sorrendben igényelhetik
az erőforrásokat.
2. A folyamat csak akkor igényelhet egy erőforrást, ha
nem használ az igényeltnél magasabb sorszámút.
• Problémák:
– Nehéz az erőforrásokat olyan módon beszámozni, hogy az
tükrözze az erőforrás szokásos sorrendjét.
– Interaktív rendszereknél nem jó (nem lehet megjósolni a
folyamatok erőforrás használatát).
• Logikailag függő folyamatokra alkalmazható.
23
4.6 Holtpont elkerülése
• A kért erőforrásokat óvatosan allokáljuk. A
rendszer minden kérésnél mérlegeli, hogy
nem vezet-e holtpontveszélyre a kérés,
fenntartható-e a
biztonságos állapot.
• Feltételezések:
– Ismerjük a folyamatok erőforrás-típusonkénti
maximális igényeit.
– Feltételezzük, hogy ha egy folyamat minden
erőforrásigényét kielégítettük, az véges időn belül
lefut.
24
4.6.1 Biztonságos állapot
• Biztonságos állapot: létezik az összes
folyamatot tartalmazó biztonságos sorozat.
• Biztonságos sorozat: a folyamatok olyan
{
P0,
P1, ...,
Pn } sorozata, ahol bármelyik
Pk
folyamat erőforrásigénye kielégíthető a
rendelkezésre álló, valamit a többi
Pi (
i < k)
folyamat által használt (és majdan
felszabadított) erőforrással.
25
A biztonságos állapot és a holtpont
• A rendszer biztonságos
állapotban van  nincs
holtpont
• A rendszer nem biztonságos
állapotban van  holtpont
lehetséges
• Holtpont elkerülése:
biztosítani kell, hogy a
rendszer soha nem kerül
nem biztonságos állapotba
holtpont
nem biztonságos
biztonságos
26
Példa: biztonságos állapot
• A kiinduló állapot biztonságos
• (1 erőforrás-osztályra, 10 erőforrással)
F M
A 3 9
B 2 4
C 2 7
Szabad: 3
Aktuális foglalás Max. igény
Éppen szabad erőforrások száma
F M
A 3 9
B 4 4
C 2 7
Szabad: 1
F M
A 3 9
B 0 -
C 2 7
Szabad: 5
F M
A 3 9
B 0 -
C 7 7
Szabad: 0
F M
A 3 9
B 0 -
C 0 -
Szabad: 7
27
Példa: nem biztonságos állapot
A második állapot már nem biztonságos!
F M
A 3 9
B 2 4
C 2 7
Szabad: 3
F M
A 4 9
B 2 4
C 2 7
Szabad: 2
F M
A 4 9
B 4 4
C 2 7
Szabad: 0
F M
A 4 9
B - -
C 2 7
Szabad: 4
28
4.6.2 Bankár algoritmus (Dijkstra,1965)
Az algoritmus előfeltételei:
1. Az erőforrás-osztályok több egyedből
állhatnak
2. Minden folyamat előzetesen megadja
maximális igényét
3. Egy igénylő folyamat várakozni
kényszerülhet
4. Ha egy folyamat megkapja az igényelt
erőforrásait, véges időn belül visszaadja.
29
Bankár algoritmus - adatszerkezetek
• n = folyamatok száma
• m = erőforrás-osztályok száma
• SZABAD: m elemű vektor. Ha SZABAD[j] = k, akkor az R j típusú
erőforrásból k példány elérhető.
• MAX: n x m méretű mátrix. A MAX[i] m elemű sorvektor jelzi, hogy
az egyes erőforrásosztályokból Pi folyamat maximum hány példányt
használhat (2. előfeltétel alapján).
• FOGLAL: n x m méretű mátrix. A FOGLAL[i] m elemű sorvektor
jelzi, hogy az egyes erőforrásosztályokból Pi folyamat jelenleg hány
példányt használ.
• MÉG: n x m méretű mátrix. A MÉG[i] m elemű sorvektor jelzi, hogy
az egyes erőforrásosztályokból Pi folyamatnak feladata
befejezéséhez még hány példányra lehet szüksége.
• KÉR: n x m méretű mátrix. A KÉR[i] m elemű sorvektor jelzi Pi
folyamat kérését az egyes erőforrásosztályokra.
• Nyilvánvalóan: MÉG[i,j] = MAX[i,j] – FOGLAL[i,j].
30
Bankár algoritmus – kérés feldolgozása
Alapötlet:
• Ha a kérés egyébként teljesíthető,
akkor tegyünk úgy, mintha már
teljesítettük volna.
• Vizsgáljuk meg, hogy ez az állapot
biztonságos-e.
• Ha igen, valóban teljesíthetjük a
kérést.
31
Bankár algoritmus – kérés feldolgozása
Pi folyamat kéri a KÉR[i] erőforrásokat:
A kérés ellenőrzése:
if KÉR[i] > MÉG[i] then STOP; (HIBA: túllépte a maximális igényt)
if KÉR[i] > SZABAD then VÉGE; (Most nincs elég szabad erőforrás)
1. A nyilvántartás átállítása az új állapotra:
SZABAD := SZABAD - KÉR[i];
FOGLAL[i] := FOGLAL[i] + KÉR[i];
MÉG[i] := MÉG[i] - KÉR[i];
2. Vizsgálat: a létrejött állapot biztonságos-e? (lásd később)
3. if BIZTONSÁGOS then
KÉRÉS TELJESÍTÉSE;
else állapot visszaállítása a (2) pont előttire:
SZABAD := SZABAD + KÉR[i];
FOGLAL[i] := FOGLAL[i]-KÉR[i];
MÉG[i] := MÉG[i] - KÉR[i];
KÉRÉS ELUTASÍTÁSA: A FOLYAMATNAK VÁRNIA KELL
32
Bankár algoritmus – biztonságos állapot vizsgálata
Működés (biztonságos sorozat keresése):
• Keressünk olyan folyamatot, ami le tud futni a most
éppen rendelkezésre álló szabad erőforráskészlettel.
• (Ha nincs ilyen, de van várakozó folyamat, akkor
holtpont van)
• A gondolatban lefuttatott folyamat által birtokolt
erőforrásokat visszaadjuk, így most már több
erőforrással próbálkozhatunk újra.
• Újabb változók:
– SZABAD_MOST: mint SZABAD. Munkaváltozó.
– LEFUT: n elemű vektor. Ha LEFUT[j] = igaz, akkor Pj folyamat
mindenképpen le tud futni.
33
Bankár algoritmus – biztonságos állapot vizsgálata
B1. Kezdőérték beállítása:
SZABAD_MOST := SZABAD
LEFUT[i] := hamis minden i-re (i=1,2,...,N)
B2. Továbblépésre esélyes folyamatok keresése:
Keress i-t amelyre (LEFUT[i] = HAMIS AND MÉG[i] <= SZABAD_MOST);
if van ilyen i, then
SZABAD_MOST := SZABAD_MOST + FOGLAL[i];
LEFUT[i] := igaz;
ismételd a B2. lépést
else folytasd a B3. lépéssel
B3. Kiértékelés
if LEFUT[i] = igaz minden i-re (i=1,2,...,N), then
BIZTONSÁGOS
else
NEM BIZTONSÁGOS
(Pi folyamatok, amelyekre LEFUT[i] = hamis holtpontra juthatnak)
34
Bankár algoritmus – jellemzés
Az algoritmus problémái:
• Időigényes
• Az alapfeltételek (ismert folyamatszám,
maximális igények, folyamat biztos
befejeződése) nem biztosíthatók.
• Túlzott óvatosság, feleslegesen várakoztat
folyamatokat (az erőforrások kihasználtsága
rosszabb, mint holtpont elkerülés nélkül).
35
Bankár algoritmus – példa
• 5 folyamat:
P0,
P1,
P2,
P3,
P4
• 3 erőforrás-osztály:
A (10),
B (5),
C (7)
• A rendszer kiinduló állapota:
Foglal Max Szabad Még
A B C A B C A B C A B C
P0 0 1 0 7 5 3 3 3 2 7 4 3
P1 2 0 0 3 2 2 1 2 2
P2 3 0 2 9 0 2 6 0 0
P3 2 1 1 2 2 2 0 1 1
P4 0 0 2 4 3 3 4 3 1
• Ez biztonságos állapot, mert van egy
biztonságos sorozat: pl. <
P1,
P3,
P4,
P2,
P0>
36
Bankár algoritmus – példa
• Teljesíthető-e P1 (1,0,2) kérése?
• Ellenőrzés:
– (1,0,2) <= (1,2,2) (KÉR[1] <= MÉG[1]: OK)
– (1,0,2) <= (3,3,2) (KÉR[1] <= SZABAD: OK)
• Kiinduló állapot:
Foglal Max Szabad Még
A B C A B C A B C A B C
P0 0 1 0 7 5 3 3 3 2 7 4 3
P1 2 0 0 3 2 2 1 2 2
P2 3 0 2 9 0 2 6 0 0
P3 2 1 1 2 2 2 0 1 1
P4 0 0 2 4 3 3 4 3 1
37
Bankár algoritmus – példa
• Kérés teljesítése (1,0,2)
Foglal Max Szabad Még
A B C A B C A B C A B C
P0 0 1 0 7 5 3 2 3 0 7 4 3
P1 3 0 2 3 2 2 0 2 0
P2 3 0 2 9 0 2 6 0 0
P3 2 1 1 2 2 2 0 1 1
P4 0 0 2 4 3 3 4 3 1
Az algoritmusban
ez a SZABAD_MOST
átmeneti változóban
tárolódik
38
Bankár algoritmus – példa
• Biztonságos sorozat keresése 1.
– P1 le tud futni
Foglal Max Szabad Még
A B C A B C A B C A B C
P0 0 1 0 7 5 3 2 3 0 7 4 3
P1 3 0 2 3 2 2 0 2 0
P2 3 0 2 9 0 2 6 0 0
P3 2 1 1 2 2 2 0 1 1
P4 0 0 2 4 3 3 4 3 1
39
Bankár algoritmus – példa
• Biztonságos sorozat keresése 1.
– P1 lefut és ...
Foglal Max Szabad Még
A B C A B C A B C A B C
P0 0 1 0 7 5 3 2 3 0 7 4 3
P1 3 0 2 3 2 2 0 2 0
P2 3 0 2 9 0 2 6 0 0
P3 2 1 1 2 2 2 0 1 1
P4 0 0 2 4 3 3 4 3 1
40
Bankár algoritmus – példa
• Biztonságos sorozat keresése 1.
– P1 lefut és erőforrásait visszaadja
Foglal Max Szabad Még
A B C A B C A B C A B C
P0 0 1 0 7 5 3 5 3 2 7 4 3
P1 0 0 0 3 2 2 -
P2 3 0 2 9 0 2 6 0 0
P3 2 1 1 2 2 2 0 1 1
P4 0 0 2 4 3 3 4 3 1
41
Bankár algoritmus – példa
• Biztonságos sorozat keresése 2.
– P3
Foglal Max Szabad Még
A B C A B C A B C A B C
P0 0 1 0 7 5 3 5 3 2 7 4 3
P1 0 0 0 3 2 2 -
P2 3 0 2 9 0 2 6 0 0
P3 2 1 1 2 2 2 0 1 1
P4 0 0 2 4 3 3 4 3 1
42
Bankár algoritmus – példa
• Biztonságos sorozat keresése 2.
– P3 lefut
Foglal Max Szabad Még
A B C A B C A B C A B C
P0 0 1 0 7 5 3 7 4 3 7 4 3
P1 0 0 0 3 2 2 -
P2 3 0 2 9 0 2 6 0 0
P3 0 0 0 2 2 2 -
P4 0 0 2 4 3 3 4 3 1
43
Bankár algoritmus – példa
• Biztonságos sorozat keresése 3.
– P4
Foglal Max Szabad Még
A B C A B C A B C A B C
P0 0 1 0 7 5 3 7 4 3 7 4 3
P1 0 0 0 3 2 2 -
P2 3 0 2 9 0 2 6 0 0
P3 0 0 0 2 2 2 -
P4 0 0 2 4 3 3 4 3 1
44
Bankár algoritmus – példa
• Biztonságos sorozat keresése 3.
– P4 lefut
Foglal Max Szabad Még
A B C A B C A B C A B C
P0 0 1 0 7 5 3 7 4 5 7 4 3
P1 0 0 0 3 2 2 -
P2 3 0 2 9 0 2 6 0 0
P3 0 0 0 2 2 2 -
P4 0 0 0 4 3 3 -
45
Bankár algoritmus – példa
• Biztonságos sorozat keresése 4.
– P2
Foglal Max Szabad Még
A B C A B C A B C A B C
P0 0 1 0 7 5 3 7 4 5 7 4 3
P1 0 0 0 3 2 2 -
P2 3 0 2 9 0 2 6 0 0
P3 0 0 0 2 2 2 -
P4 0 0 0 4 3 3 -
46
Bankár algoritmus – példa
• Biztonságos sorozat keresése 4.
– P2 lefut
Foglal Max Szabad Még
A B C A B C A B C A B C
P0 0 1 0 7 5 3 10 4 7 7 4 3
P1 0 0 0 3 2 2 -
P2 0 0 0 9 0 2 -
P3 0 0 0 2 2 2 -
P4 0 0 0 4 3 3 -
47
Bankár algoritmus – példa
• Biztonságos sorozat keresése 5.
– P0
Foglal Max Szabad Még
A B C A B C A B C A B C
P0 0 1 0 7 5 3 10 4 7 7 4 3
P1 0 0 0 3 2 2 -
P2 0 0 0 9 0 2 -
P3 0 0 0 2 2 2 -
P4 0 0 0 4 3 3 -
48
Bankár algoritmus – példa
• Biztonságos sorozat keresése 5.
– P0 lefut
Foglal Max Szabad Még
A B C A B C A B C A B C
P0 0 0 0 7 5 3 10 5 7 -
P1 0 0 0 3 2 2 -
P2 0 0 0 9 0 2 -
P3 0 0 0 2 2 2 -
P4 0 0 0 4 3 3 -
Biztonságos sorozat: <
P1 ,
P3 ,
P 4,
P2 ,
P0 >
49
Bankár algoritmus – gyakorló példák
1. Teljesíthető-e P4 (3,3,0) kérése?
2. Teljesíthető-e P0 (0,2,0) kérése?
Kiinduló állapot: Foglal Max Szabad
A B C A B C A B C
P0 0 1 0 7 5 3 3 3 2
P1 2 0 0 3 2 2
P2 3 0 2 9 0 2
P3 2 1 1 2 2 2
P4 0 0 2 4 3 3
50
4.7 A holtpont felismerése
• Egyszeres erőforrások esete
– Kör keresése az erőforrás-foglalási gráfban
• Többszörös erőforrások esete
– Itt a kör nem elégséges feltétel, tehát
bonyolultabb vizsgálat kell.
– Hasonlóan a biztonságos állapot
vizsgálatánál közölt algoritmushoz
(vigyázat: nem ugyanaz az algoritmus!)
51
Coffman algoritmus - adatszerkezetek
• N = folyamatok száma
• M = erőforrás-osztályok száma
• SZABAD: m elemű vektor. Ha SZABAD[j] = k, akkor az
Rj típusú erőforrásból k példány elérhető.
• SZABAD_MOST: mint SZABAD. Munkaváltozó.
• FOGLAL: n x m méretű mátrix. A FOGLAL[i] m elemű
sorvektor jelzi, hogy az egyes erőforrásosztályokból Pi
folyamat jelenleg hány példányt használ.
• KÉR: n x m méretű mátrix. A KÉR[i] m elemű sorvektor
jelzi Pi folyamat kérését az egyes erőforrásosztályokra.
• LEFUT: n elemű vektor. Ha LEFUT[j] = igaz, akkor a Pj
folyamat
a mostani erőforrásigények szerint le tud futni.
52
Holtpont-detektáló algoritmus (Coffman)
C1. Kezdőérték beállítása:
SZABAD_MOST := SZABAD
LEFUT[i] := hamis minden i-re (i=1,2,...,N)
C2. Továbblépésre esélyes folyamatok keresése:
Keress i-t amelyre (LEFUT[i] = HAMIS AND KÉR[i] <= SZABAD_MOST);
if van ilyen i, then
SZABAD_MOST := SZABAD_MOST + FOGLAL[i];
LEFUT[i] := igaz;
ismételd a C2. lépést
else folytasd a C3. lépéssel
C3. Kiértékelés
if LEFUT[i] = igaz minden i-re (i=1,2,...,N), then
NINCS HOLTPONT
else
HOLTPONT:
Azon Pi folyamatok, amelyekre LEFUT[i] = hamis
53
Coffman algoritmus – példa
• Kiinduló állapot:
Foglal Kér Szabad
A B C A B C A B C
P0 0 1 0 0 0 0 0 0 0
P1 2 0 0 2 0 2
P2 3 0 3 0 0 0
P3 2 1 1 1 0 0
P4 0 0 2 0 0 2
• Van-e holtpont?
– Nincs: <P0 , P2 , P3 , P1 , P4 >
• Mi a helyzet, ha P2 kér még egy C-t?
– Holtpont: (P 1 , P2 , P3 , P4 )
54
A holtpont-detektálás időzítése
Mikor kell a detektáló algoritmust futtatni?
• Erőforrás-igény kielégítésekor
– Sok időt igényel
– Rögtön kiderül a holtpont
– Tudjuk, melyik folyamat zárta be a holtpontot
• Meghatározott időnként
– Nehéz meghatározni a megfelelő gyakoriságot
– Túl sűrű futtatás: sok időt igényel
– Túl ritka futtatás: holtpont sokáig fennáll
55
4.8 A holtpont felszámolása
• Holtpont felismerése után azt -
operátori beavatkozással vagy
automatikusan - fel kell számolni.
• Módszerek:
1. Folyamatok terminálása
2. Erőforrások elvétele
56
A holtpont felszámolása: folyamatok terminálása
• Minden holtpontban résztvevő folyamatot
megszüntetünk (radikális)
– Biztos, de költséges (megszűnt folyamatok
eredményei elvesznek)
• Egyesével szüntetjük meg folyamatokat, amíg
a holtpont meg nem szűnik.
– Minden terminálás után újabb detektálás
– Szempontok a folyamat kiválasztásához:
• hány holtpont körben szerepel
• mekkora a prioritása
• mennyi ideje futott, mennyit futna még (ha ismerjük)
• mennyi erőforrást tart lefoglalva
• mennyi további erőforrásra lenne szüksége
• interaktív vagy batch program
57
A holtpont felszámolása: erőforrások elvétele
• A holtpontra jutott folyamatoktól egyesével
elvesszük az erőforrásokat.
• Megoldandó problémák:
– Kitől vegyük el és melyik erőforrást?
– Kiszemelt folyamatot vissza kell léptetni egy olyan
állapotba, ahonnan a futását folytatni tudja
(leggyakrabban újra kell kezdenie a futását).
Egyes OS-ek a folyamatokhoz ellenőrzési pontokat
rendelnek (checkpoint); a futást a legutóbbi
ellenőrzési ponttól kell folytatni.
– El kell kerülni a folyamatok kiéheztetését (ne
mindig ugyanattól a folyamattól vegyünk el
erőforrásokat).
58
4.9 Kombinált holtpont-kezelő stratégiák
Erőforrásokat csoportokra osztjuk, és az egyes csoportokra
különböző stratégiát alkalmazunk. Pl.:
• Belső erőforrások (rendszertáblák, leírók, stb.)
– Rendszer-folyamatokat érinti. Folyamatok létrejöttekor azonos
sorrendben igénylik ezen erőforrásokat, a rendezett erőforrás-
foglalás könnyen megvalósítható.
• Operatív tár
– Menthető állapotú erőforrás, így alkalmazható az erőszakos elvétel
módszere.
• Egy munkához tartozó erőforrások (állományok, eszközök)
– A munka leírásából ismerhetjük az igényeket, használhatunk
holtpont elkerülő algoritmust.
• Munkaterület a lemezen (swap)
– általában ismert igények vannak, egyszerre kell kérni a szükséges
méretet, nincs rákérés (előzetes lefoglalás).
ME
D/F
EK
ME
ME
59
4.10 Kommunikációs holtpontok
• Holtponthelyzet nemcsak erőforrás-használat miatt
alakulhat ki, hanem folyamatok tetszőleges olyan
együttműködése során, amely a folyamatok körkörös
várakozásra vezet.
• Pl.
– Kliens-szerver architektúrájú rendszer, ahol az ügyfelek és a
szolgáltatók is folyamatok. Az ügyfél-szolgáltató lánc záródik.
• A gráfos reprezentáció itt is használható: várakozási
gráf (wait-for graph)
– csomópontjai a folyamatok
– irányított élei pedig a várakozást jelzik (várakozóból a
várakoztatóhoz vezet).
Operációs rendszerek
5. Ütemezés
Felhasznált irodalom:
• Kóczy-Kondorosi (szerk.): Operációs rendszerek mérnöki megközelítésben
• Tanenbaum: Modern Operating Systems 2nd. Ed.
• Silberschatz, Galvin, Gagne: Operating System Concepts v3.0
2
Tartalom
• Bevezetés
• CPU ütemezés
• Ütemezési algoritmusok alapjai
• Ütemezési algoritmusok
3
5.1 Bevezetés
OS legfontosabb feladata
• a rendszer erőforrásainak kezelése,
• a folyamatoknak a futásukhoz szükséges
erőforrásokkal való ellátása
• bizonyos szempontok alapján
– gazdálkodási,
– védelmi, stb.
• Az ütemezés (scheduling) az a tevékenység,
amely eredményeként eldől, hogy az adott
erőforrást a következő pillanatban mely
folyamat használhatja.
4
5.2 CPU ütemezés
Három különböző szint van:
• Hosszútávú (long term) ütemezés vagy
munka ütemezés:
• Középtávú (medium term) ütemezés
• Rövidtávú (short term) ütemezés
•
Nem minden OS-ben van meg mindegyik
típusú ütemezés.
5
Hosszú távú ütemezés
• Hosszútávú (
long term) ütemezés vagy munka
ütemezés:
– A háttértáron várakozó, még el nem kezdett munkák
közül melyek kezdjenek futni.
– Ritkán kell futnia; egy munka befejeződésekor
választunk ki egy új elindítandót.
– Ritkán fut, így nem kell, hogy gyors legyen.
• Követelmény:
– olyan munka-halmaz (
job-mix) előállítása, amely a
rendszer erőforrásait kiegyensúlyozottan használja.
– CPU-korlátozott és periféria-korlátozott munkák
egyenletesen forduljanak elő.
6
Középtávú ütemezés
• Középtávú (
medium term) ütemezés
• A rendszer időszakos terhelés-
ingadozásait egyes folyamatok
felfüggesztésével illetve újraaktiválásával
próbálja kiegyenlíteni.
• Felfüggesztés esetén folyamat a
háttértáron tárolódik, megfosztják
elvehető erőforrásaitól.
• Az ilyen folyamatok nem versengenek
tovább az erőforrásokért.
7
Rövidtávú ütemezés
• Rövidtávú (
short term) ütemezés
– Mely futásra kész folyamat kapja meg a
CPU-t (kerül futó állapotba)
– Gyakran fut, ezért gyorsnak kell lennie,
különben a rendszer túl sok időt töltene az
ütemezéssel, elvéve a CPU-t a folyamatoktól.
– Az ütemező mindig a tárban van, része a OS
magjának.
8
Emlékeztető:
folyamatok kibővített állapotai
Futásra
kész Várakozik
Fut
létrejön
elindul
futás
megszakad
esemény
bekövetkezik
eseményre vár
megszűnik
Felfüggesztve
várakozik
Felfüggesztve
kész
aktivál
felfüggeszt
esemény
bekövetkezik
Aktív
állapotok
Passzív
állapotok
Rövidtávú
ütemezés
Hoszútávú
ütemezés
Középtávú
ütemezés
Középtávú
ütemezés
9
5.3 Az ütemezési algoritmusok alapjai
• Egy folyamat futása során két különböző jellegű
tevékenységet végez:
• CPU löket (CPU burst) ideje alatt a folyamatnak
csak CPU-ra és az operatív tárra van szüksége.
• Periféria löket (I/O burst) alatt a folyamat
perifériás átvitelt hajt végre, annak lezajlására
várakozik.
• A folyamatnak periféria löket alatt nincs
szüksége a CPU-ra.
• CPU löket átlagos hossza folyamatonként
változik
10
A CPU löket és az IO löket 1.
• (a) CPU-korlátos folyamat
• (b) I/O-korlátos folyamat
(a)
(b)
várakozás I/O-ra
hosszú CPU löket
rövid CPU löket
11
A CPU löket és az IO löket 2.
load store
add store
read from file
store increment
index
write to file
load store
add store
read from file
wait for I/O
wait for I/O
wait for I/O
CPU löket
CPU löket
CPU löket
I/O löket
I/O löket
I/O löket
12
A CPU löket eloszlása
CPU löket
folyamatok (%)
13
Hol történik ütemezés?
Ütemezés a következő állapotátmeneteknél
következik be:
1. A futó folyamat várakozni kényszerül
2. A futó folyamat lemond a CPU-ról vagy
elveszik tőle
3. A folyamat futásra késszé válik (nem
mindig van ütemezés)
4. A futó folyamat befejeződik
14
1. A futó folyamat várakozni kényszerül
Futásra
kész Várakozik
Fut
létrejön
elindul
futás
megszakad
esemény
bekövetkezik
eseményre vár
megszűnik
Felfüggesztve
várakozik
Felfüggesztve
kész
aktivál
felfüggeszt
esemény
bekövetkezik
Aktív
állapotok
Passzív
állapotok
15
2. A futó folyamat lemond a CPU-ról, vagy
elveszik tőle
Futásra
kész Várakozik
Fut
létrejön
elindul
futás
megszakad
esemény
bekövetkezik
eseményre vár
megszűnik
Felfüggesztve
várakozik
Felfüggesztve
kész
aktivál
felfüggeszt
esemény
bekövetkezik
Aktív
állapotok
Passzív
állapotok
16
3. A folyamat futásra késszé válik
Futásra
kész Várakozik
Fut
létrejön
elindul
futás
megszakad
esemény
bekövetkezik
eseményre vár
megszűnik
Felfüggesztve
várakozik
Felfüggesztve
kész
aktivál
felfüggeszt
esemény
bekövetkezik
Aktív
állapotok
Passzív
állapotok
17
4. A futó folyamat befejeződik
Futásra
kész Várakozik
Fut
létrejön
elindul
futás
megszakad
esemény
bekövetkezik
eseményre vár
megszűnik
Felfüggesztve
várakozik
Felfüggesztve
kész
aktivál
felfüggeszt
esemény
bekövetkezik
Aktív
állapotok
Passzív
állapotok
18
Ütemezés és környezetváltás
• Ütemezés tehát a következő
állapotátmeneteknél következik be:
1. a futó folyamat várakozni kényszerül
2. futó folyamat lemond a CPU-ról vagy elveszik tőle
3. folyamat futásra késszé válik
4. a futó folyamat befejeződik
• Az 1. és 4. esetben
mindig van környezetváltás
(hiszen a futó folyamat nem folytatja a
működését).
• A 2. és 3. esetben
nem mindig van
környezetváltás.
19
Ütemezés típusai
Az ütemezés típusa
• Nem preemptív, ha egy folyamattól, miután
megkapta a CPU-t, nem lehet azt elvenni.
– a folyamat csak az általa kiadott utasítások hatására
vált állapotot.
• erőforrásra, eseményre várakozás
• befejeződés vagy
• a CPU-ról önként lemondás
• preemptív, ha az OS elveheti a futás jogát egy
folyamattól
– futásra kész állapotba teszi a futó folyamatot és
– egy másik (futásra kész) folyamatot indít el.
– Pl. időosztásos, valósidejű OS-ek
20
Az ütemezési algoritmusok
teljesítményének mérése I.
• Az ütemezési algoritmusok teljesítményének
mérésére a következő paramétereket szokták
használni:
• CPU kihasználtság (CPU utilization)
– A CPU az idejének hány százalékát használja a
folyamatok utasításainak végrehajtására.
Kihasználtságot csökkenti: CPU henyél (idle),
rendszer-adminisztrációra fordított idő (rezsi) sok.
• Átbocsátó képesség (throughput)
– Az OS időegységenként hány munkát futtat le.
21
Az ütemezési algoritmusok
teljesítményének mérése II.
• További paraméterek a teljesítmény mérésére:
• Körülfordulási idő (turnaround time)
– Egy munka a rendszerbe helyezéstől számítva
mennyi idő alatt fejeződik be.
• Várakozási idő (waiting time)
– Egy munka (vagy folyamat) mennyi időt tölt
várakozással (futásra kész állapot, várakozó állapot,
felfüggesztett állapotok, (long-term) előzetes
várakozás).
• Válaszidő (response time)
– Időosztásos (interaktív) rendszereknél fontos. Az OS
reakció ideje, a kezelői parancs után a rendszer első
látható reakciójáig eltelt idő.
22
Teljesítménymérés
fut
rendszerbe helyezés
kész
reakció
Tresponse
Tturnaround
Twaiting
vár
23
Az ütemezési algoritmusokkal szembeni
követelmények 1.
• valamely (előbbi paraméterekből képzett)
célfüggvény szerint legyen optimális
• legyen korrekt, kezeljen minden folyamatot
(vagy bizonyos típusú folyamatokat) azonos
módon (igazságos).
• biztosítson egyes folyamatoknál prioritást
• kerülje el a folyamatok kiéheztetését
• legyen megjósolható viselkedésű (meg
lehessen becsülni a várható maximális
körülfordulási időt)
• minimalizálja a rezsi időt (gyakran kis többlet
adminisztrációval jobb általános
rendszerteljesítmény érhető el)
24
Az ütemezési algoritmusokkal szembeni
követelmények 2.
• részesítse előnyben
– a kihasználatlan erőforrásokat igénylő folyamatokat
– a fontos erőforrásokat foglaló folyamatokat
• növekvő terhelés esetén a rendszer
teljesítménye "elegánsan", fokozatosan
romoljon le (graceful degradation), ne
omoljon hirtelen össze.
• Sok cél egymásnak ellentmond, így azok
együttesen nem teljesíthetők.
• Fontos megfogalmazni egy rendszer tervezése
folyamán azokat a célokat, amelyek kiemelt
fontosságúak.
25
5.4 Ütemezési algoritmusok
• Egyszerű algoritmusok
• Prioritásos algoritmusok
• Többszintű algoritmusok
• Többprocesszoros ütemezés
26
5.4.1 Egyszerű ütemezési algoritmusok
• Legrégebben várakozó (First Come First
Served, FCFS)
• Körforgó (Round-Robin, RR)
27
Legrégebben várakozó
First Come First Served, FCFS
– A futásra kész folyamatok a várakozási sor
végére kerülnek, az ütemező a sor elején álló
folyamatot kezdi futtatni.
– Nem preemptív.
– Egyszerűen megvalósítható
– Konvoj hatás (egy hosszú CPU löketű
folyamat feltartja a mögötte várakozókat).
28
Példa: FCFS
Végrehajtási sorrend: P1, P2, P 3
Átlagos várakozási idő:
Átlagos körülfordulási idő:
Átbocsátó képesség:
Végrehajtási sorrend: P2, P3 , P 1
Átlagos várakozási idő:
Átlagos körülfordulási idő:
Átbocsátó képesség:
P i Ci (ms)
P 1 24
P 2 3
P 3 3
29
Megoldás: FCFS
Végrehajtási sorrend: P1, P2, P 3
Átlagos várakozási idő: (24+27)/3=17ms
Átlagos körülfordulási idő: (24+27+30)/3=27ms
Átbocsátó képesség: 3job/30ms=1/10 job/ms
Végrehajtási sorrend: P2, P3 , P 1
Átlagos várakozási idő: (3+6)/3=3ms
Átlagos körülfordulási idő: (3+6+30)/3=13ms
Átbocsátó képesség: 3job/30ms=1/10 job/ms
Konvoj
effektus!
P i Ci (ms)
P 1 24
P 2 3
P 3 3
30
Körforgó
Round-Robin, RR
– Preemptív algoritmus, az időosztásos
rendszerek valamennyi ütemezési
algoritmusainak az alapja.
– Folyamatok időszeletet kapnak (time slice).
• Ha a CPU löket nagyobb mint az időszelet, akkor
az időszelet végén az ütemező elveszi a CPU-t, a
folyamat futásra kész lesz és beáll a várakozó sor
végére.
• Ha a CPU löket rövidebb, akkor a löket végén a
folyamatokat újraütemezzük.
31
Körforgó ütemezés időszelete
• Időszelet meghatározása nehéz.
– Nagy időszelet: FCFS algoritmushoz hasonló
lesz.
– Kis időszelet: folyamatok a CPU-t egyenlő
mértékben használják, viszont a sok
környezetváltás a teljesítményt rontja.
• Ökölszabály: a CPU löketek kb. 80%
legyen rövidebb az időszeletnél.
• Általában 10-100ms
32
Példa:
Round Robin
T slice =4ms
Pi Ci (ms)
P1 24
P2 3
P3 3
P 1
4
?
33
Megoldás:
Round Robin
T slice =4ms
Pi Ci (ms)
P1 24
P2 3
P3 3
P 1 P 1 P 1 P 1 P 1 P 1P 2 P 3
4 7 10 14 18 22 26 30
34
Példa: Round Robin
• Az időszelet (Tslice ) hatása a környezetváltás
gyakoriságára
• Ci = 10ms
Tslice Környezetváltások száma
12 0
6 1
1 9
35
5.4.2 Prioritásos ütemező algoritmusok
• A futásra kész folyamatokhoz egy
prioritást (rendszerint egy egész számot)
rendelünk.
• A legnagyobb prioritású folyamat lesz a
következő futtatandó folyamat.
36
Prioritás
• Meghatározása
– belső
• az OS határozza meg
– külső
• az OS-en kívüli tényező (operátor, a folyamat
saját kérése, stb.) határozza meg
• Futás során
– statikus (végig azonos)
– dinamikus (az OS változtathatja)
37
Példa: Statikus prioritás
Átlagos várakozási idő: ?
Folyamat Ci (ms) Prioritás
P1 10 3
P2 1 1
P3 2 3
P4 1 4
P5 5 2
P 2
0 1
?
38
Megoldás: Statikus prioritás
Átlagos várakozási idő: (6+0+16+18+1)/5=8.2
Folyamat Ci (ms) Prioritás
P1 10 3
P2 1 1
P3 2 3
P4 1 4
P5 5 2
P 1 P 3 P 4
P 2
0 1 6 16 18 19
P 5
random
39
Prioritás meghatározása
• Prioritást sokszor a löketidő alapján
határozzák meg.
• A löketidő szükséglet meghatározása:
– a folyamat (felhasználó) bevallása alapján (a
„hazugságot” az OS később bünteti)
– előző viselkedés alapján (a korábbi löketidők
alapján becslés)
40
A kiéheztetés és elkerülése
• Kiéheztetés:
– A folyamat sokáig (esetleg soha) nem jut
processzorhoz
• Prioritásos algoritmusoknál kiéheztetés
felléphet
• Ennek kivédése a folyamatok öregítése
(
aging):
– a régóta várakozó folyamatok prioritását
növeljük
41
Egy éhes folyamat
• Klasszikus példa: MIT, 1973
• Folyamat: 1967-ből
IBM 7094
42
Dinamikus prioritásos algoritmusok
• Legrövidebb (löket)idejű
–
Shortest Job First, SJF
• Legrövidebb hátralévő idejű
–
Shortest Remaining Time First, SRTF
• Legjobb válaszarány
–
Highest Response Ratio
43
Legrövidebb (löket)idejű
Shortest Job First, SJF
• Nem preemptív algoritmus, a futásra kész
folyamatok közül a legrövidebb löketidejűt
indítja.
• Nincs konvoj hatás, optimális körülfordulási idő,
optimális várakozási idő.
• Alkalmazása:
– Hosszú távú ütemezés
– Rövid távú ütemezés (RT rendszerek)
44
Legrövidebb hátralévő idejű
Shortest Remaining Time First, SRTF
• Az SJF
preemptív változata
• Ha egy új folyamat válik futásra késszé
– akkor az ütemező újra megvizsgálja a futásra kész
folyamatok, illetve az éppen futó folyamatot
hátralévő löketidejét
– és a legrövidebbet indítja tovább.
• A folyamat megszakítása és egy másik elindítása
környezetváltozást igényel, ezt az időt is
figyelembe kell vennünk.
45
Példa: SRTF
Ütemezés?
Átlagos várakozási idő: ?
P 1
0 1
?
Pi T i (ms) Ci (ms)
P1 0 8
P2 1 4
P3 2 9
P4 3 5
46
Példa megoldás: SRTF
Átlagos várakozási idő: (9+0+15+2)/4=6.5ms
Pi T i (ms) Ci (ms)
P1 0 8
P2 1 4
P3 2 9
P4 3 5
P 1 P 1P 2
0 3 5 101 2 17 26
P 4 P 3
P1: 7
P2: 4
P1: 7
P2: 3
P3: 9
P1: 7
P2: 2
P3: 9
P4: 5
P1: 7
P3: 9
P4: 5
P1: 7
P3: 9
P3: 9
47
Legjobb válaszarány
Highest Response Ratio
• Az SJF algoritmus változata, ahol a várakozó
folyamatok öregednek. A kiválasztás (a löketidő
helyett) a
képlet szerint megy végbe, ahol
k egy jól
megválasztott konstans.
löketidő
idővárakozásiklöketidő _
48
5.4.3 Többszintű algoritmusok
• Futásra kész folyamatokat több külön sorban
várakoztatják.
• A sorokhoz prioritás van rendelve.
• Egy kisebb prioritású sorból csak akkor indulhat
el egy folyamat, ha a nagyobb prioritású sorok
üresek.
• Az egyes sorokon belül különböző kiválasztási
algoritmusok működhetnek.
• Példák:
– Statikus többszintű sorok
– Visszacsatolt többszintű sorok
49
Statikus többszintű sorok
•
Static Multilevel Queue, SMQ
• A folyamatot elindulásakor valamilyen kritérium alapján
besorolunk egy várakozó sorba.
• A folyamat élete során végig ugyanabban a sorban
marad.
system
interactive
interactive editing
batch
sorok (példa)
prioritás végrehajtás
statistics
50
Statikus többszintű sorok
• Egy lehetséges példa a prioritások besorolására:
– rendszer folyamatok (magas prioritás, közvetlen
hatással vannak a rendszer működésére)
– interaktív folyamatok (biztosítani kell a felhasználó
számára az elfogadható válaszidőt)
– interaktív szövegszerkesztők (kevésbé kritikusak)
– kötegelt feldolgozás (általában akkor futnak, ha "van
idő")
– rendszerstatisztikákat gyűjtő folyamatok (alacsony
prioritás, nincsenek közvetlen hatással a rendszer
működésére)
51
Visszacsatolt többszintű sorok
•
Multilevel Feedback Queues, MFQ
• A sorokhoz egy időszelet tartozik:
– minél nagyobb a prioritás, annál kisebb az időszelet
• A folyamatok futásuk során átkerülhetnek másik sorokba
prioritás végrehajtás
sorok (példa)
8 ms
16 ms
24 ms
FCFS
52
Visszacsatolt többszintű sorok
A folyamatok sor- és prioritás-váltása
• Nagyobb prioritásúból kisebb prioritású sorba:
– Amennyiben nem elég az adott időszelet, a folyamat
egy kisebb prioritású sorba kerül át.
• Kisebb prioritásúból nagyobb prioritású sorba:
– A folyamat átlagos löketidejének változása
(csökkenése) esetén
– A régóta várakozó folyamat öregedése miatt
53
5.5 Többprocesszoros ütemezés
• Napjainkban egyre jobban terjednek a
többprocesszoros - szorosan csatolt -
rendszerek, ahol felmerül az igény, hogy a
futásra kész folyamatok a rendszer
bármely processzorán elindulhassanak.
•
Heterogén rendszerek esetében egy
folyamat csak bizonyos processzorokon
futhat.
•
Homogén rendszerekben a futásra kész
folyamatokat közös sorokban tárolja.
54
Homogén többprocesszoros rendszerek
•
Homogén rendszerekben a futásra kész
folyamatokat közös sorokban tárolja.
– Szimmetrikus multiprocesszoros rendszer
Minden CPU saját ütemezőt futtat, amely a
közös sorokból választ. A sorok osztott
használatához a kölcsönös kizárást biztosítani
kell!
– Aszimmetrikus multiprocesszoros rendszer
Az ütemező egy dedikált CPU-n fut, ez osztja
szét a folyamatokat a szabad CPU-k között.
55
5.6 Az algoritmusok értékelésének
módszerei
• Analitikus értékelés
– Determinisztikus modellezés:
• Előre elkészített adatokkal vizsgáljuk az algoritmus viselkedését.
• Egyszerű, de az eredmények csak szűk körben érvényesek.
– Sztochasztikus modellezés:
• Az adateloszlások paraméterei adottak
• Az algoritmusok matematikai eszközökkel vizsgálhatók
• sorbanállás elmélete, queueing theory
• Szimuláció
– Korábbi tapasztalatok alapján meghatározott véletlen eloszlású
számokkal vizsgáljuk az algoritmus működését.
– Az eredmények nagyban függnek az adatok helyességétől.
• Implementáció
– A legmegbízhatóbb megoldás az algoritmusok implementálása és
teljesítményük valós körülmények közötti mérése.
– A legköltségesebb megoldás.
56
Esettanulmány
• Completely fair scheduler
• Ingo Molnar
• http://immike.net/blog/2007/08/01/what-
is-the-completely-fair-scheduler/
Kérdések és válaszok kihagyása
Kérdések és válaszok
"1. Mi az operációs rendszerek célja?"
"1. Az operációs rendszerek célja a felhasználók kényelmének biztosítása egyszerű, kényelmes és biztonságos használaton keresztül, valamint a gép hatékony kihasználásának elősegítése adott idő alatt minél több program végrehajtásával"

"2. Adja meg az operációs rendszer szűkebb és tágabb definícióját!"
"2. A szűkebb definíció szerint az operációs rendszer az a program, amely közvetlenül vezérli a gép működését, és az összes program, ami a szállítótól 'operációs rendszer' néven érkezik. A tágabb definíció szerint az operációs rendszer magában foglal minden gyakorlati feladatot ellátó programot, és minden olyan szoftvert, ami a gép 'általános' felhasználásához szükséges."

"3. Adja meg az operációs rendszer 3 fő feladatát! Adjon rövid magyarázatot is!"
"3. Az operációs rendszer három fő feladata a végrehajtási környezet biztosítása, erőforrások kiosztása, és vezérlő program funkció. A végrehajtási környezet biztosítása magában foglalja a felhasználók és programjaik számára a hasznos munkavégzést. Az erőforrások kiosztása során az operációs rendszer kezeli a rendszer erőforrásait, mint például a CPU-t, memóriát és merevlemezt. A vezérlő program funkció az operációs rendszer egyik alapvető feladata, amely a felhasználói programok működését vezérli."

"4. Definiálja, hogy mi az a végrehajtási környezet!"
"4. A végrehajtási környezet olyan környezetet jelent, ahol a felhasználók és programjaik hasznos munkát végezhetnek. Ez magában foglalja a számítógép hardver szolgáltatásainak bővítését, és elrejti a részleteket a könnyű felhasználhatóság érdekében."

"5. Milyen tulajdonságokat kell biztosítani az operációs rendszernek az erőforrás kiosztás során?"
"5. Az operációs rendszernek hatékony, biztonságos és igazságos erőforrás-kiosztást kell biztosítania. Ez magában foglalja a rendszer erőforrásainak, mint például a CPU, központi tár és merevlemez, kezelését."

"6. Mi jellemezte az első generációs rendszereket?"
"6. Az első generációs rendszerekre a nagy, drága és megbízhatatlan hardverek, valamint a plugboard vezérelt CPU és egyszerű perifériák voltak jellemzőek. Használatuk során a programozó volt egyben az operátor is, kézi vezérléssel és gépidő foglalással."

"7. Mi jellemezte a második generációs rendszereket?"
"7. A második generációs rendszerek kisebb, olcsóbb és megbízhatóbb hardverekkel rendelkeztek, egyszerű perifériákkal és mágnesszalaggal. Ebben az időszakban a programozó és az operátor szerepe szétvált, a képzett operátorok gyorsabb

gepkezelést tettek lehetővé, de a hibakeresés még nem volt jelen."

"8. Mutassa be, hogy mi az a kötegelt feldolgozás!"
"8. A kötegelt feldolgozás olyan feldolgozási módszer, ahol a feladatokat kötegekbe (batch) csoportosítják, és egyszerre több feladatot visznek be a gépbe a soros feldolgozás érdekében. Ez lehetővé teszi, hogy a gép folyamatosan dolgozzon anélkül, hogy várakoztatni kellene a következő feladat bevitelét."

"9. Mutassa be, hogy mi a Spooling!"
"9. A Spooling (Simultaneous Peripheral Operations On-line) egy olyan folyamat, amelyben a lassú perifériák adatait a feldolgozásig mágneslemezen tárolják, lehetővé téve a munkák perifériás és feldolgozási műveleteinek átlapolódását és a lemez véletlen hozzáférését."

"10. Mik a multiprogramozás lépései?"
"10. A multiprogramozás lépéseit az jellemzi, hogy a rendszer nyilvántartja a futtatandó munkákat, a kiválasztott munka addig fut, amíg várakozni nem kényszerül, ekkor az operációs rendszer kiválaszt egy másik munkát a folytatáshoz. Ha a félbehagyott munka feltételei teljesülnek, az újra elindítható."

"11. Mutassa be, az időosztásos rendszer főbb tulajdonságait!"
"11. Az időosztásos rendszerek főbb tulajdonságai közé tartozik a gyors reakcióidő, a felhasználók számára nyújtott interaktív működés és az a képesség, hogy a felhasználók úgy érezzék, mintha egyedül használnák a gépet, bár valójában a rendszer időszeleteket oszt ki közöttük."

"12. Mutassa be, hogy mi az elosztott operációs rendszer!"
"12. Az elosztott operációs rendszer olyan rendszer, ahol a számítási feladatokat több gép között osztják meg a hálózaton keresztül, lehetővé téve az erőforrások megosztását, a terhelés megosztását, a megnövelt megbízhatóságot és a könnyebb kommunikációt."

"13. Mik az elosztott operációs rendszerek előnyei?"
"13. Az elosztott operációs rendszerek előnyei közé tartozik az erőforrások megosztása, a terhelés megosztása, a megnövelt megbízhatóság, a skálázhatóság és a felhasználók közötti könnyebb kommunikáció."

"14. Mutassa be az operációs rendszerek szerkezetét!"
"14. Az operációs rendszerek szerkezete moduláris, rétegzett felépítésű, ahol a rétegek egymásra épülnek és az alattuk lévő réteggel jól definiált interfészen keresztül kommunikálnak, egyre bővülő funkcionalitást nyújtva a felhasználónak."

"15. Adja meg a rendszerhívás definícióját!"
"15. A rendszerhívás az operációs rendszer és a programok közötti interfész, amely lehetővé teszi a programok számára, hogy biztonságos módon hozzáférjenek az operációs rendszer alacsony szintű szolgáltatásaihoz."

"16. Mik a rendszerhívás lépései?" "16. A rendszerhívás lépései magukban foglalják a paraméterek átadását, a hívás megtételét egy speciális gépi utasítással (trap), ami átadja a vezérlést az operációs rendszernek, az operációs rendszer által végzett műveletek végrehajtását, majd a vezérlés visszaadását a hívó programnak."

"17. Adja meg a fontosabb rendszermodulokat!" "17. A fontosabb rendszermodulok közé tartoznak a folyamatkezelő, memóriakezelő, fájlrendszer-kezelő, eszközkezelő, hálózatkezelő és a felhasználói interfész kezelése."

"18. Adjon meg legalább 3 operációs rendszer szolgáltatást!" "18. Az operációs rendszer szolgáltatásai között szerepel a folyamatok vezérlése, állományok kezelése és a perifériás eszközök kezelése."

"19. Definiálja, hogy mik azok a rendszerprogramok, adjon rá néhány példát is!" "19. A rendszerprogramok olyan programok, amelyek az operációs rendszer általános célú felhasználását támogatják. Példák rendszerprogramokra: parancsértelmező, szövegszerkesztő, fordító programok, kommunikációs programok."

"20. Adja meg a folyamat definícióját!" 

"20. A folyamat a multiprogramozott operációs rendszerek alapfogalma, amely egy végrehajtás alatt álló programot jelent."

"21. Sorolja fel a multi programozott rendszerben a folyamatok lehetséges állapotait, röviden írja is körül őket!" 

"21. A multi programozott rendszerben a folyamatok lehetséges állapotai: futásra kész, fut, várakozik. A futásra kész állapotban a folyamat vár a CPU-ra, a fut állapotban a CPU a folyamat utasításait hajtja végre, és a várakozik állapotban a folyamat egy külső esemény bekövetkezésére vár."

"22. Sorolja fel a multi programozott rendszerben a folyamatok lehetséges állapotátmeneteit!"

 "22. A multi programozott rendszerben a folyamatok lehetséges állapotátmenetei közé tartozik a folyamat létrehozása, futásra kész állapotból fut állapotba való átmenet, fut állapotból várakozik állapotba való átmenet, várakozik állapotból futásra kész állapotba való átmenet, és a folyamat befejeződése."



Holtpont kihagyása
Holtpont

1.
Adott az alábbi rendszer: P1, P2, P3 folyamatok, E1 erőforrás osztály 2 erőforrással, E2 erőforrás osztály 1
erőforrással. P1 egy E1 osztálybeli erőforrást használ és egy E2 osztálybeli erőforrást igényel, P2 egy E2
osztálybeli erőforrást használ és egy E1 osztálybeli erőforrást igényel, P3 egy E1 osztálybeli erőforrást használ.
Mondja meg, hogy van-e körkörös várakozás a rendszerben, indokolja válaszát!


2.
Adott az alábbi rendszer: P1, P2, P3 folyamatok, E1 erőforrás osztály 1 erőforrással, E2 erőforrás osztály 2
erőforrással, E3 erőforrás osztály 1 erőforrással, E4 erőforrás osztály 3 erőforrással. P1 egy E2 erőforrás
osztálybeli erőforrást használ és egy E1 erőforrás osztálybeli erőforrást igényel. P2 egy E1 és egy E2 erőforrás
osztálybeli erőforrást használ és egy E3 erőforrás osztálybeli erőforrást igényel. P3 egy E3 erőforrás osztálybeli
erőforrást használ és egy E2 erőforrás osztálybeli erőforrást igényel. Mondja meg, hogy van-e holtpont a
rendszerben, indokolja válaszát!


3.
Adott egy rendszer, amelyben 1 erőforrás osztály van, 10 erőforrással. A rendszerben 3 folyamat (A, B, C)
található, amelyek az alábbi táblázatban található foglalásokkal és igényekkel rendelkeznek. F = aktuális
foglalás, M = maximális igény.
F M
A 3 9
B 2 4
C 2 7
Mondja meg, hogy a rendszer biztonságos állapotban van-e! Válaszát indokolja is!



4.
Adott egy rendszer 5 folyamattal (P0, …, P4), három erőforrás osztállyal (A, B, C) és az alábbi erőforrás
foglalásokkal. F = aktuális foglalás, M = maximális igény.
F M
A B C A B C
P0 0 1 0 7 5 3
P1 2 0 0 3 2 2
P2 3 0 2 9 0 2
P3 2 1 1 2 2 2
P4 0 0 2 4 3 3
A rendszerben A erőforrás osztályban 3, B erőforrás osztályban 3, C erőforrás osztályban pedig 2 szabad
erőforrás van pillanatnyilag.
Adja meg, hogy teljesíthető-e P4 (A=3, B=3, C=0) erőforrás igénylése! Válaszát indokolja is!



Az első rendszerben:
P1 használ egy E1 erőforrást és igényel egy E2 erőforrást.
P2 használ egy E2 erőforrást és igényel egy E1 erőforrást.
P3 használ egy E1 erőforrást. Itt nem áll fenn körkörös várakozás, mert P3 nem igényel további erőforrást, így nem zár be egy körkörös függőségi láncot. Bár P1 és P2 között fennáll egy oda-vissza igénylés, P3 hiányzó igénylése miatt nem alakulhat ki teljes kör.
A második rendszerben:
P1 használ egy E2 erőforrást és igényel egy E1 erőforrást.
P2 használ egy E1 és egy E2 erőforrást, és igényel egy E3 erőforrást.
P3 használ egy E3 erőforrást és igényel egy E2 erőforrást. Itt fennáll a körkörös várakozás, mivel minden folyamat igényel egy olyan erőforrást, amit egy másik folyamat már használ. Ez a függőségi lánc holtpontot okoz, mert nincs olyan folyamat, amely befejeződhetne az erőforrás-felszabadítás érdekében, hiszen mindegyik egy másik által használt erőforrást vár.
A harmadik rendszerben: Az összes erőforrás száma 10. Az A, B, és C folyamatok aktuális foglalása 3+2+2=7, tehát 3 erőforrás szabad még. Mivel minden folyamat maximális igénye (9+4+7=20) meghaladja az elérhető (10) és a szabad (3) erőforrások összegét, ez nem feltétlenül jelenti azt, hogy a rendszer biztonságos állapotban van. Azonban, ha a rendszer képes kielégíteni a folyamatok maximális igényeit anélkül, hogy holtpontba kerülne, akkor biztonságos állapotban van. Ebben az esetben, anélkül, hogy a pontos Bankár algoritmust alkalmaznánk, nehéz megállapítani, hogy biztonságos állapotban van-e a rendszer, mivel az igények és a rendelkezésre álló erőforrások alapján holtpont potenciálisan előfordulhat.

A negyedik rendszerben: A rendszerben jelenleg 3 A, 3 B, és 2 C szabad erőforrás van. P4 (A=3, B=3, C=0) erőforrás igénye teljesíthető, mivel pontosan elegendő A és B erőforrás áll rendelkezésre, és nem igényel C erőforrást. Tekintettel arra, hogy a rendelkezésre álló erőforrások kielégítik P4 igényeit, és nincsen szükség további C erőforrásra, az igény teljesíthető.


Ütemezés kihagyása
Ütemezés
1.
Adott négy folyamat (P i , i=1...4), amelyeknek futásideje Ci. A folyamatok Ti időpontban kerülnek futásra kész
állapotba. A rendszerben körforgó (RR) CPU ütemezés működik, az időszelet hossza 3 ms.
i Ti (ms) C i (ms)
1 1 3
2 3 6
3 0 2
4 10 5
5 4 1
Folytassa az alábbi időtengelyen az ütemezést!
P P3
t(ms) 0 1 2 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
Számolja ki az átbocsátó képességet (throughput)!
Számolja ki az átlagos körülfordulási időt (turnaround time)!
Számolja ki az átlagos várakozási időt (waiting time)!



2.
Adott négy folyamat (P i , i=1...4), amelyeknek futásideje Ci . A folyamatok Ti időpontban kerülnek futásra kész
állapotba. A rendszerben legrégebben várakozó (FCFS) CPU ütemezés működik.
i Ti (ms) C i (ms)
1 1 3
2 4 6
3 0 2
4 10 1
5 4 3
Folytassa az alábbi időtengelyen az ütemezést!
P P3
t(ms) 0 1 2 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
Számolja ki az átbocsátó képességet (throughput)!
Számolja ki az átlagos körülfordulási időt (turnaround time)!
Számolja ki az átlagos várakozási időt (waiting time)!



3.
Adott öt folyamat (P i , i=1...5), amelyeknek futásideje Ci . Az operációs rendszer a legrövidebb löketidejű (Shortest
Job First - SJF) algoritmus szerint ütemez. Az egyes folyamatok az alábbi táblázatban megadott időpontokban (Ti)
kerülnek futásra kész állapotba.
i Ti (ms) C i (ms)
1 1 5
2 5 3
3 0 7
4 13 2
5 4 1
Folytassa az alábbi időtengelyen az ütemezést!
P P3
t(ms) 0 1 2 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
Számolja ki az átbocsátó képességet (throughput)!
Számolja ki az átlagos körülfordulási időt (turnaround time)!
Számolja ki az átlagos várakozási időt (waiting time)!



4.
Adott öt folyamat (P i , i=1...5), amelyeknek futásideje Ci . Az operációs rendszer a legrégebben várakozó (First
Come First Served - FCFS) algoritmus szerint ütemez. Az egyes folyamatok az alábbi táblázatban megadott
időpontokban (Ti) kerülnek futásra kész állapotba.
i Ti (ms) C i (ms)
1 1 5
2 5 3
3 0 7
4 13 2
5 4 1
Folytassa az alábbi időtengelyen az ütemezést!
P P3
t(ms) 0 1 2 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
Számolja ki az átbocsátó képességet (throughput)!
Számolja ki az átlagos körülfordulási időt (turnaround time)!
Számolja ki az átlagos várakozási időt (waiting time)!



5.
Adott öt folyamat (P i , i=1...5), amelyeknek futásideje Ci, prioritása pedig Prioritás i . Az operációs rendszer a
statikus prioritás algoritmus szerint ütemez. Az egyes folyamatok paraméterei az alábbi táblázatban találhatóak.
i C i (ms) Prioritási
1 10 3
2 1 1
3 2 3
4 1 4
5 5 2
Folytassa az alábbi T időtengelyen az ütemezést!
P P3
t(ms) 0 1 2 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
Számolja ki az átbocsátó képességet (throughput)!
Számolja ki az átlagos körülfordulási időt (turnaround time)!
Számolja ki az átlagos várakozási időt (waiting time)!



1. Körforgó (RR) CPU ütemezés
Időtengely:

P3 kezd (0-2 ms)
P1 kezd (3 ms-ban kész) - időszelet alatt befejeződik (1-3 ms)
P2 kezd (3-6 ms) - első időszelet (3-6 ms), marad 3 ms
P5 kezd (6-7 ms-ban kész) - időszelet alatt befejeződik
P2 folytatódik (7-10 ms) - második időszeletben befejeződik
P4 kezd (10-13 ms) - első időszelet (marad 2 ms)
P4 folytatódik (13-15 ms-ban kész)
Átbocsátó képesség (throughput): 5 folyamat / 15 ms = 0.333 folyamat/ms

Átlagos körülfordulási idő (turnaround time):

P1: 3 - 1 = 2 ms
P2: 10 - 3 = 7 ms
P3: 2 - 0 = 2 ms
P4: 15 - 10 = 5 ms
P5: 7 - 4 = 3 ms
Átlagos körülfordulási idő = (2 + 7 + 2 + 5 + 3) / 5 = 19 / 5 = 3.8 ms

Átlagos várakozási idő (waiting time): A várakozási idők a körülfordulási időkből számolhatók ki, a futási idők levonásával.

P1: 2 - 3 = -1 ms (nem várakozik)
P2: 7 - 6 = 1 ms
P3: 2 - 2 = 0 ms
P4: 5 - 5 = 0 ms
P5: 3 - 1 = 2 ms
Átlagos várakozási idő = (0 + 1 + 0 + 0 + 2) / 5 = 3 / 5 = 0.6 ms




FCFS CPU ütemezés
Adatok:

P1: T1=1ms, C1=3ms
P2: T2=4ms, C2=6ms
P3: T3=0ms, C3=2ms
P4: T4=10ms, C4=1ms
P5: T5=4ms, C5=3ms
Ütemezés:
0-2ms: P3 fut (0-tól 2ms-ig, mert 2ms a futási ideje).
2-5ms: P1 fut (1ms-től kezdve, de P3 már futott, tehát P1 2ms-tól 5ms-ig fut).
5-8ms: P5 fut (4ms-től kezdve, de P1 után kerül sorra, tehát 5ms-tól 8ms-ig fut).
8-14ms: P2 fut (4ms-től kezdve, de P5 után kerül sorra, tehát 8ms-tól 14ms-ig fut).
14-15ms: P4 fut (10ms-tól kezdve, de az utolsó a sorban, tehát 14ms-tól 15ms-ig fut).

Átbocsátó képesség (throughput):
5 folyamat fejeződik be 15ms alatt, tehát az átbocsátó képesség: 5/15 folyamat/ms.

Átlagos körülfordulási idő (turnaround time):
P3: 2ms
P1: 4ms (5-1)
P5: 4ms (8-4)
P2: 10ms (14-4)
P4: 5ms (15-10)
Átlag: (2+4+4+10+5)/5 = 25/5 = 5ms

Átlagos várakozási idő (waiting time):
A várakozási idő a körülfordulási időből a CPU idő levonásával kapható meg:

P3: 0ms (mivel rögtön fut)
P1: 1ms (4-3)
P5: 1ms (4-3)
P2: 4ms (10-6)
P4: 4ms (5-1)
Átlag: (0+1+1+4+4)/5 = 10/5 = 2ms



A legrövidebb löketidejű (SJF) algoritmus szerinti ütemezésnél az a folyamat kapja a CPU-t, amelynek a legkisebb a futásideje. Ha több folyamat érkezik egyszerre, a legkisebb futási idővel rendelkező kerül előre.

Adatok:
P1: T1=1ms, C1=5ms
P2: T2=5ms, C2=3ms
P3: T3=0ms, C3=7ms
P4: T4=13ms, C4=2ms
P5: T5=4ms, C5=1ms
Ütemezés:
0-7ms: P3 fut (0-tól kezdődően, mert ez az első érkező és 7ms a futásideje).
7-8ms: P5 fut (legkisebb futásidejű a rendelkezésre álló folyamatok közül).
8-13ms: P1 fut (mivel ez a következő legkisebb futásidejű a fennmaradó folyamatok közül).
13-16ms: P2 fut (P4 érkezése előtt P2-nek van a legkisebb futásideje).
16-18ms: P4 fut (ez az utolsó folyamat, 2ms futásidejével).

Számítások:
Átbocsátó képesség (throughput):
5 folyamat fejeződik be 18ms alatt, tehát az átbocsátó képesség: 5/18 folyamat/ms.

Átlagos körülfordulási idő (turnaround time):
P3: 7ms (0-tól 7-ig tart a futása)
P5: 8-4=4ms
P1: 13-1=12ms
P2: 16-5=11ms
P4: 18-13=5ms
Átlag: (7+4+12+11+5)/5 = 39/5 = 7.8ms

Átlagos várakozási idő (waiting time):
A várakozási idő a körülfordulási időből levonva a tiszta futási időt:

P3: 0ms (azonnal fut)
P5: 4-1=3ms
P1: 12-5=7ms
P2: 11-3=8ms
P4: 5-2=3ms
Átlag: (0+3+7+8+3)/5 = 21/5 = 4.2ms



Az FCFS (First Come First Served) algoritmus szerinti ütemezésnél a folyamatokat azon sorrendben dolgozzuk fel, ahogy megérkeznek, figyelmen kívül hagyva a futási idejüket.

Adatok:
P1: T1=1ms, C1=5ms
P2: T2=5ms, C2=3ms
P3: T3=0ms, C3=7ms
P4: T4=13ms, C4=2ms
P5: T5=4ms, C5=1ms
Ütemezés:
0-7ms: P3 fut, mivel ez az első érkező folyamat.
7-12ms: P1 fut, a következő érkező.
12-13ms: P5 fut, mivel ez a harmadik érkezési sorrendben.
13-16ms: P2 fut, a negyedik érkező.
16-18ms: P4 fut, az utolsó érkező folyamat.

Számítások:
Átbocsátó képesség (throughput):
5 folyamat fejeződik be 18ms alatt, tehát az átbocsátó képesség: 5/18 folyamat/ms.

Átlagos körülfordulási idő (turnaround time):
P3: 7ms (mivel 0-tól 7-ig fut)
P1: 12-1=11ms
P5: 13-4=9ms
P2: 16-5=11ms
P4: 18-13=5ms
Átlag: (7+11+9+11+5)/5 = 43/5 = 8.6ms

Átlagos várakozási idő (waiting time):
A várakozási idő a körülfordulási időből levonva a tiszta futási időt:

P3: 0ms (azonnal kezd)
P1: 11-5=6ms
P5: 9-1=8ms
P2: 11-3=8ms
P4: 5-2=3ms
Átlag: (0+6+8+8+3)/5 = 25/5 = 5ms




5. feladat: Statikus prioritás alapú CPU ütemezés
A statikus prioritás alapú ütemezés során a legmagasabb prioritású folyamatok kapják meg először a processzort. Azonos prioritás esetén az érkezési sorrend dönt.

Adatok:

P1: Ci=10ms, Prioritási=3
P2: Ci=1ms, Prioritási=1 (Legmagasabb prioritás)
P3: Ci=2ms, Prioritási=3
P4: Ci=1ms, Prioritási=4 (Legalacsonyabb prioritás)
P5: Ci=5ms, Prioritási=2
Ütemezés:

Először a P2 folyamat fut, mivel ez rendelkezik a legmagasabb prioritással.
Ezután a P5 következik, mint a második legmagasabb prioritású folyamat.
A P1 és a P3 azonos, 3-as prioritásúak, de nincs közvetlen információnk arról, hogy melyik érkezett előbb, így alapértelmezés szerint az i index sorrendjében ütemezünk, tehát először P1, majd P3.
Végül P4, mint a legalacsonyabb prioritású folyamat.
Időtengely:

0-1ms: P2 fut, mert ez a legmagasabb prioritású.
1-6ms: P5 fut, második legmagasabb prioritású.
6-16ms: P1 fut, harmadik a prioritási sorrendben.
16-18ms: P3 fut, mivel azonos prioritású P1-gyel, de később kerül sorra.
18-19ms: P4 fut, mint a legalacsonyabb prioritású.
Számítások:

Átbocsátó képesség (throughput): 5 folyamat fejeződik be 19ms alatt, tehát az átbocsátó képesség: 5/19 folyamat/ms.

Átlagos körülfordulási idő (turnaround time):

P2: 1ms
P5: 6ms - 0 = 6ms
P1: 16ms - 0 = 16ms
P3: 18ms - 0 = 18ms
P4: 19ms - 0 = 19ms
Átlag: (1+6+16+18+19)/5 = 60/5 = 12ms

Átlagos várakozási idő (waiting time): A várakozási idő a körülfordulási időből levonva a futási időt:

P2: 0ms (azonnal fut)
P5: 1ms
P1: 6ms
P3: 16ms
P4: 18ms
Átlag: (0+1+6+16+18)/5 = 41/5 = 8.2ms



Portáltámogatás elérése
Fogl Barna néven lépett be (Kilépés)
A felhasználói túra visszaállítása ezen az oldalon
Adatmegőrzés összegzése
Töltse le a Moodle-t a mobiljára
Szolgáltat